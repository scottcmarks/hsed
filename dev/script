:set -Wno-type-defaults
:set prompt-cont ""

:load dev/DevMain.hs
:set -XQuasiQuotes
:set -XOverloadedStrings
:set -XDataKinds
:set -XTemplateHaskell
:set -XRankNTypes
:set -XGADTs
:set -XStandaloneDeriving
:set -XKindSignatures

import System.IO
putStrLn "loading script ..."
--------------------------------------------------------------------------------

import Data.ByteString(head,tail)
import Data.Either(Either(..))
import Data.Foldable(mapM_)
import Data.Functor((<$>))
import Data.Maybe(Maybe(..))
import Data.Text(cons, snoc, pack, unpack)
import GHC.Arr(range)
import GHC.Base(flip,map,pure,(.),($),(*>),(<*>),(<*),(<>))
import GHC.Classes((<))
import GHC.Err(undefined)
import GHC.Show(show)
import GHC.Base(const, (++))
:def! $ (pure . (":! bash -l -c " ++) . show)
:def! B (pure . (":! bash -l -c \"stack build\"" ++) . show)
:def! D (pure . const (":set -ddump-splices") )
:def! H (pure . (":! bash -l -c \"./h\"" ++) . show)
:def! P (pure . (":! bash -l -c \"./hp\"" ++) . show)

--------------------------------------------------------------------------------


import Data.Char (toUpper)

:load src/Data/SizedText/TH.hs
:load src/Data/SizedText.hs
import Data.ByteString hiding(take,length,putStrLn)

:i take
:t take $(sz "Hello")
:t take $(sz "Hello") :: C.Sized ByteString 4 32
take $(sz "Hello") :: C.Sized ByteString 4 32
length (take $(sz "Hello") :: C.Sized ByteString 4 32)
take $(sz "Hello") :: C.Sized ByteString 4 32
take $(sz "Hello") :: C.Sized ByteString 4 4
take $(sz "HelloHelloHelloHelloHelloHelloHello") :: C.Sized ByteString 4 32
:i create
:i ByteString
"Hello" :: ByteString
create ("Hello" :: ByteString) :: Maybe (C.Sized ByteString 4 32)
create ("Hello" :: ByteString) :: Maybe (C.Sized ByteString 4 32)
create ("Hello" :: ByteString) :: Maybe (C.Sized ByteString 4 4)
create ("Hello" :: ByteString) :: Maybe (C.Sized ByteString 8 32)
$(sz "Hello")

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

$(sz "foo")
:t it
type TCG_bytes n = C.Sized ByteString n n
type TCG_maxbytes n = C.Sized ByteString 0 n
type TCG_bytes_8 = TCG_bytes 8
type TCG_maxbytes_8 = TCG_maxbytes 8

import GHC.Word(Word8)
import Data.ByteString.Internal(c2w)
fill = c2w '_'
b = createLeft fill "bolo" :: TCG_bytes_8
b
:i b
length b

newtype TCG_some_bytes    =  TCG_some_bytes ByteString    deriving (Eq,Show)
newtype TCG_some_maxbytes =  TCG_some_maxbytes ByteString deriving (Eq,Show)

import Data.String(IsString(..))
instance IsString TCG_some_bytes    where fromString = TCG_some_bytes . fromString
instance IsString TCG_some_maxbytes where fromString = TCG_some_maxbytes . fromString

sb = "lobo" :: TCG_some_bytes
sb
:t sb

putStrLn "Buh-bye now."


--------------------------------------------------------------------------------

putStrLn ".. script loaded."
