:set -Wno-type-defaults
:set prompt-cont ""

:load dev/DevMain.hs
:set -XQuasiQuotes
:set -XOverloadedStrings
:set -XDataKinds
:set -XTemplateHaskell
:set -XRankNTypes
:set -XGADTs
:set -XStandaloneDeriving
:set -XKindSignatures

import System.IO
putStrLn "loading script ..."
--------------------------------------------------------------------------------

import Data.ByteString(head,tail)
import Data.Either(Either(..))
import Data.Foldable(mapM_)
import Data.Functor((<$>))
import Data.Maybe(Maybe(..))
import Data.Text(cons, snoc, pack, unpack)
import GHC.Arr(range)
import GHC.Base(flip,map,pure,(.),($),(*>),(<*>),(<*),(<>))
import GHC.Classes((<))
import GHC.Err(undefined)
import GHC.Show(show)
import GHC.Base(const, (++))
:def! $ (pure . (":! bash -l -c " ++) . show)
:def! B (pure . (":! bash -l -c \"stack build\"" ++) . show)
:def! D (pure . const (":set -ddump-splices") )
:def! H (pure . (":! bash -l -c \"./h\"" ++) . show)
:def! P (pure . (":! bash -l -c \"./hp\"" ++) . show)

--------------------------------------------------------------------------------


import Data.Char (toUpper)
import Data.ByteString (ByteString)
import Data.String(IsString(..))
import Data.SizedText.Class(IsSizedText(Sized))
import GHC.Word(Word8)
import Data.ByteString.Internal(c2w)
import Language.Haskell.TH
import Language.Haskell.TH.Ppr
import Language.Haskell.TH.PprLib
import Data.Either(Either(..))
import Data.String(String)
import Data.BoundedSize(BoundedSize(..))
import Data.BoundedSize(IsBytes(..))

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


:i Core_integer
:i Core_bytes
:k Core_bytes
:k Core_bytes 5
safeCreate "Scott" :: Either String (BoundedSize 5 5 ByteString)
safeCreate "Scott" :: Either String (FixedSize 5 ByteString)

:set -XDerivingVia
:t safeCreate
:i IsBytes
:set -XUndecidableInstances
newtype Core_some_bytes = Core_some_bytes ByteString deriving (IsBytes,IsString,Show) via ByteString
:i Core_some_bytes
import Data.String(IsString(..))
safeCreate "Scott" :: Either String (BoundedSize 5 5 Core_some_bytes)
:t it
safeCreate "Scott" :: Either String (FixedSize 5 Core_some_bytes)
:t it
:i IsString
:i Core_bytes

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

putStrLn "Buh-bye now."


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

putStrLn ".. script loaded."
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
