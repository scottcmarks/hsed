:load dev/DevMain.hs
:set -fno-warn-type-defaults
:set -fno-warn-unused-imports
:set -XDataKinds
:set -XTemplateHaskell
:set -XQuasiQuotes
:set -XOverloadedStrings
:set prompt-cont ""

import System.IO
putStrLn "loading script ..."
--------------------------------------------------------------------------------

import           Language.Haskell.TH
import           Language.Haskell.TH.Ppr
import           Language.Haskell.TH.PprLib
import           Language.Haskell.TH.Syntax       (Dec, mkName, returnQ)

import           Data.Attoparsec.ByteString hiding(parse)
import           Data.Attoparsec.ByteString.Char8(parse,skipSpace,isEndOfLine)
import           Data.ByteString(ByteString)
import           Data.ByteString.Char8(pack, unpack)
import           Data.Either(Either(..),either,fromRight)
import           Data.Foldable(concatMap, mapM_, maximum)
import           Data.Function(($),(&))
import           Data.Functor((<$>),(<&>))
import           Data.List(maximum, (\\))
import           Data.Map(fromList, fromListWith)
import           Data.String(String, fromString)
import           Data.Tuple(fst, snd)

import           GHC.Arr(range)
import           GHC.Base(id, map, mconcat, pure,(.),(<*),(<*>),(*>),(>>=))
import           GHC.Enum(Bounded(..), Enum(..))
import           GHC.Err(error)
import           GHC.Classes(Eq(..), Ord(..))
import           GHC.Maybe(Maybe(..))
import           GHC.Show(Show(..))
import           GHC.Types(Int)


import           System.SED.Common.TableUIDs
import           System.SED.Common.THUtil
import           System.SED.Common.UID
import           System.SED.Common.ColumnTypes.TH

pQ = (ppr <$>) . runQ
showQ = (\h -> h & pQ <&> show >>= putStrLn)

import Text.Heredoc

pT = ppr . ttypeDecs


:{
table51 = [here|

                     Table 51 adv_key_mode
    +-----------------------+------------+-----------------+
    |UID                    |Name        |Format           |
    +-----------------------+------------+-----------------+
    |00 00 00 05 00 00 04 0F|adv_key_mode|Enumeration_Type,|
    |                       |            |0,               |
    |                       |            |7                |
    +-----------------------+------------+-----------------+

|] :: String
:}
putStrLn "table51 ====>"
pT table51

-- pE = ppr . tenumDecs

:{
table52 = [here|

     Table 52 adv_key_mode Enumeration Values
    +------------------+---------------------+
    |Enumeration Value |Behavior             |
    +------------------+---------------------+
    |0                 |Wait for AdvKey_Req  |
    +------------------+---------------------+
    |1                 |Auto-advance keys    |
    +------------------+---------------------+
    |2-7               |Reserved             |
    +------------------+---------------------+

|] :: String
:}

:{
table121 = [here|

    Table 121 padding_type Enumeration Values
    +-----------------+-------------------+
    |Enumeration Value|Associated Value   |
    +-----------------+-------------------+
    |0                |None               |
    +-----------------+-------------------+
    |1                |None               |
    +-----------------+-------------------+
    |2                |RSAES-PKCS1-v1_5   |
    +-----------------+-------------------+
    |3                |RSAES-OAEP         |
    +-----------------+-------------------+
    |4                |RSASSA-PKCS1-v1_5  |
    +-----------------+-------------------+
    |5-15             |Reserved           |
    +-----------------+-------------------+
|]
:}

bs121 = pack table121

(enumName, enumRows) = either error id $ parseOnly enumTableParser bs121
putStrLn enumName
mapM_ (putStrLn . show) enumRows
coreName = "Core_" ++ enumName
putStrLn coreName

:{
enumRowValueLabelPairs :: EnumRow -> [(String, [Int])]
enumRowValueLabelPairs (EnumRow n vs) = map pairUp vs
  where pairUp v = (mconcat[coreName, "_", n], [v])
:}

givenPairs = concatMap enumRowValueLabelPairs enumRows
putStr $ "givenPairs=" ++ show givenPairs ++ "\n"

mapM_ print givenPairs

givenRange = concatMap snd givenPairs

maxv = maximum givenRange

fullRange = range(0,maxv)

missingValues = fullRange \\ givenRange

putStr $ "missingValues=" ++ show missingValues ++ "\n"

fillInPairs = map (\v -> (mconcat[coreName, "_NA"]::String, [v])) missingValues

putStr $ "fillInPairs=" ++ show fillInPairs ++ "\n"

fullPairs = fillInPairs ++ givenPairs

putStr $ "fullPairs=" ++ show fullPairs ++ "\n"


consolidatedPairs = fromListWith (flip(++)) fullPairs :: Map String [Int]
mapM_ print $ toList consolidatedPairs

-- t52QDecs = (returnQ <$> tenumDecs) table52

-- showQ $ t52QDecs

putStrLn "Buh-bye now."

--------------------------------------------------------------------------------
import GHC.Base(const, (++))
:def! $ (pure . (":! bash -l -c " ++) . show)
:def! B (pure . (":! bash -l -c \"stack build\"" ++) . show)
:def! D (pure . const (":set -ddump-splices") )
:def! H (pure . (":! bash -l -c \"./h\"" ++) . show)
:def! P (pure . (":! bash -l -c \"./hp\"" ++) . show)
putStrLn ".. script loaded."
