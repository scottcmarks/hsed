:load dev/DevMain.hs
:set -XQuasiQuotes
:set -XOverloadedStrings
:set prompt-cont ""

import Data.Either(Either(..))
import Data.Foldable(foldr)
import Data.Functor((<$>))
import Data.Text(cons, snoc, pack, unpack)
import GHC.Arr(range)
import GHC.Base(map,pure,(.),($),(*>),(<*>),(<*))
import GHC.Classes((<))
import GHC.List(filter)
import GHC.Show(show)
import Text.Megaparsec(parse)

import System.IO
putStrLn "loading script ..."
--------------------------------------------------------------------------------


import Text.Heredoc
import Data.Text(Text, length, lines, unlines, replace, pack, unpack)

:{

  {-
  (from RFC 5234)

     [T]he version of a ruleset included in a
     specification might need preprocessing to ensure that it can
     be interpreted by an ABNF parser.
  -}

removeEmptyLines :: Text -> Text
removeEmptyLines = unlines . filter ((0 <) . length) . lines

preprocessABNF :: Text -> Text
preprocessABNF = replace "_" "-"
               . removeEmptyLines
               . ((flip (foldr replacer)) pairs)
  where
    replacer (s, i) = replace (item (s, i) " ") (item (s, i) " %d")
    item (s, i) = (s `cons`) .  (`snoc` i)
    pairs = [(s, i) | s <- "=/", i <- range ('0','9')]



coreTypesTCGABNF = [here|
Type = Base_Type / Simple_Type / Enumeration_Type / Alternative_Type / List_Type /
Restricted_Reference_Type / General_Reference_Type / Named_Value_Type / Struct_Type
/ Set_Type


table_kind = 1/2


Base_Type = 0

Simple_Type = 1 bytes_8 uinteger_2

Enumeration_Type = 2 1*(uinteger_2 uinteger_2)

Alternative_Type = 3 2*bytes_8

List_Type = 4 uinteger_2 bytes_8

Restricted_Reference_Type = 5/6 1*bytes_8

General_Reference_Type = 7/8/9

General_Reference_Table_Type = 10 table_kind

Named_Value_Name_Type = 11 1*32bytes bytes_8

Name_Value_Integer_Type = 12 integer_2 bytes_8

Name_Value_Uinteger_Type = 13 uinteger_2 bytes_8

Struct_Type = 14 1*bytes_8

Set_Type = 15 1*(uinteger_2 uinteger_2)

|] :: Text

coreTypesABNF =[here|
Type = Base-Type / Simple-Type / Enumeration-Type / Alternative-Type / List-Type / Restricted-Reference-Type / General-Reference-Type / Named-Value-Type / Struct-Type / Set-Type
table-kind = %d1 / %d2
Base-Type = %d0
Simple-Type =  %d1 bytes-8 uinteger-2
Enumeration-Type = %d2 1*(uinteger-2 uinteger-2)
Alternative-Type = %d3 2*bytes-8
List-Type = %d4 uinteger-2 bytes-8
Restricted-Reference-Type = %d5 / %d6 1*bytes-8
General-Reference-Type = %d7 / %d8 / %d9
General-Reference-Table-Type = %d10 table-kind
Named-Value-Name-Type = %d11 1*32bytes bytes-8
Name-Value-Integer-Type = %d12 integer-2 bytes-8
Name-Value-Uinteger-Type = %d13 uinteger-2 bytes-8
Struct-Type = %d14 1*bytes-8
Set-Type = %d15 1*(uinteger-2 uinteger-2)
|] :: Text

correctABNFToTCGABNF :: Text -> Text
correctABNFToTCGABNF = replace "-" "_" . replace "%d" ""

coreTypesTCGABNF' :: Text
coreTypesTCGABNF' = correctABNFToTCGABNF coreTypesABNF
:}

import Text.ABNF
import Text.ABNF.PrettyPrinter
import Data.Foldable(mapM_)

:{
case parseABNF "~/hsed/dev/script FIXME" coreTypesABNF of
  Left _peb -> putStrLn "failed"
  Right rules -> mapM_ putStrLn [ show rules
                                , ""
                                , unpack $ correctABNFToTCGABNF $ pack
                                         $ prettyShow rules]
:}


putStrLn "Buh-bye now."

--------------------------------------------------------------------------------
import GHC.Base(const, (++))
:def! $ (pure . (":! bash -l -c " ++) . show)
:def! B (pure . (":! bash -l -c \"stack build\"" ++) . show)
:def! D (pure . const (":set -ddump-splices") )
:def! H (pure . (":! bash -l -c \"./h\"" ++) . show)
:def! P (pure . (":! bash -l -c \"./hp\"" ++) . show)
putStrLn ".. script loaded."
