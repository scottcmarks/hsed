-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on Github at
--   <a>https://github.com/scottcmarks/hsed#readme</a>
@package hsed
@version 0.1.0.1


-- | Use this module when you need to add an <a>IsSizedText</a> instance to
--   a type.
module Data.SizedText.Class

-- | Class of types which can be assigned a type-level minimum and maximum
--   length.
class IsSizedText a where {
    
    -- | Data family which wraps values of the underlying type giving them a
    --   type-level length. <tt>Sized t 6 10</tt> means a value of type
    --   <tt>t</tt> of length between 6 and 10.
    data family Sized a (l :: Nat) (u :: Nat);
    
    -- | Basic element type. For <tt>IsSizedText [a]</tt>, this is <tt>a</tt>.
    type family Elem a;
}

-- | Simply wrap a value in a Sized as is, assuming any length.
--   
--   <b>WARNING</b> Use it only when you know what you're doing.
--   
--   For example, an expression like
--   
--   <pre>
--   unsafeCreate "somestring" :: Sized String 50 100
--   </pre>
--   
--   will typecheck, although the stored length information will not match
--   actual string size. This may result in wrong behaviour of all
--   functions defined for <a>IsSizedText</a>.
--   
--   When writing new <a>IsSizedText</a> instances, make this simply apply
--   the constructor of <a>Sized</a>.
unsafeCreate :: IsSizedText a => a -> Sized a l u

-- | Forget type-level minimum and maximum length, obtaining the underlying
--   value.
unwrap :: IsSizedText a => Sized a l u -> a
length :: IsSizedText a => a -> Int
append :: IsSizedText a => a -> a -> a
replicate :: IsSizedText a => Int -> Elem a -> a
map :: IsSizedText a => (Elem a -> Elem a) -> a -> a
take :: IsSizedText a => Int -> a -> a
drop :: IsSizedText a => Int -> a -> a

-- | Class of types which can be assigned a type-level fixed length.
type Static a (l :: Nat) = Sized a l l

-- | Extract type-level Nat as a value-level Int &gt;&gt;&gt; fromNat
--   (Proxy @5) 5
fromNat :: KnownNat n => proxy n -> Int

-- | Elements on the left are preferred. &gt;&gt;&gt; createLeft ' '
--   "foobarbaz" :: Sized String 0 6 "foobar" &gt;&gt;&gt; createLeft '@'
--   "foobarbaz" :: Sized String 12 20 "foobarbaz@@@"
createLeft :: forall a l u. (IsSizedText a, KnownNat l, KnownNat u) => Elem a -> a -> Sized a l u

-- | Just like <a>createLeft</a>, except that elements on the right are
--   preferred. &gt;&gt;&gt; createRight '@' "foobarbaz" :: Sized String 0
--   6 "barbaz" &gt;&gt;&gt; createRight <tt>#</tt> "foobarbaz" :: Sized
--   String 12 20 "###foobarbaz"
createRight :: forall a l u. (IsSizedText a, KnownNat l, KnownNat u) => Elem a -> a -> Sized a l u

-- | Attempt to safely create a Sized if it matches target length.
--   
--   <pre>
--   &gt;&gt;&gt; create "foobar" :: Maybe (Sized String 6 10)
--   Just "foobar"
--   
--   &gt;&gt;&gt; create "barbaz" :: Maybe (Sized String 0 4)
--   Nothing
--   </pre>
--   
--   This is safer than <a>unsafeCreate</a> and unlike with
--   <a>createLeft</a> <a>createRight</a> the source value is left
--   unchanged. However, this implies a further run-time check for Nothing
--   values.
create :: forall a (l :: Nat) (u :: Nat). (IsSizedText a, KnownNat l, KnownNat u) => a -> Maybe (Sized a l u)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.SizedText.Class.Sized [a] l u)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.SizedText.Class.Sized [a] l u)
instance GHC.Classes.Ord (Data.SizedText.Class.Sized Data.Text.Internal.Text l u)
instance GHC.Classes.Eq (Data.SizedText.Class.Sized Data.Text.Internal.Text l u)
instance GHC.Classes.Ord (Data.SizedText.Class.Sized Data.ByteString.Internal.ByteString l u)
instance GHC.Classes.Eq (Data.SizedText.Class.Sized Data.ByteString.Internal.ByteString l u)
instance GHC.Classes.Ord (Data.SizedText.Class.Sized Data.ByteString.Short.Internal.ShortByteString l u)
instance GHC.Classes.Eq (Data.SizedText.Class.Sized Data.ByteString.Short.Internal.ShortByteString l u)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.SizedText.Class.Sized (Data.Vector.Vector a) l u)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.SizedText.Class.Sized (Data.Vector.Vector a) l u)
instance (GHC.Show.Show a, Data.SizedText.Class.IsSizedText a) => GHC.Show.Show (Data.SizedText.Class.Sized a l u)
instance Data.SizedText.Class.IsSizedText [a]
instance Data.SizedText.Class.IsSizedText Data.Text.Internal.Text
instance Data.SizedText.Class.IsSizedText Data.ByteString.Internal.ByteString
instance Data.SizedText.Class.IsSizedText Data.ByteString.Short.Internal.ShortByteString
instance Data.SizedText.Class.IsSizedText (Data.Vector.Vector a)


-- | Template Haskell helpers for SizedText.
module Data.SizedText.TH
st :: LitS -> Q Exp

-- | Type-safe Sized constructor macros for string literals.
--   
--   Example:
--   
--   <pre>
--   $(sz "Foobar")
--   </pre>
--   
--   compiles to
--   
--   <pre>
--   unsafeCreate "Foobar" :: forall a. (IsString a, IsSizedText a) =&gt; Sized a 0 6
--   </pre>
--   
--   where 6 is the string length obtained at compile time.
sz :: LitS -> Q Exp

-- | Construct &gt; unsafeCreate <a>Foobar</a> :: forall a. (IsString a,
--   IsSizedText a) =&gt; typef a l u where l and u are the type-level
--   KnownNat versions of the bounds of s
unsafeCreateExp :: (Name -> Int -> Int -> Type) -> Name -> Int -> Int -> String -> Exp
instance Data.String.IsString Data.SizedText.TH.LitS


-- | sized-text combinators are defined for members of <a>IsSizedText</a>
--   class. The package includes <a>IsSizedText</a> instances for several
--   common types.
--   
--   This module is meant to be imported qualifed, e.g.
--   
--   <pre>
--   import qualified Data.SizedText as S
--   </pre>
module Data.SizedText

-- | Elements on the left are preferred. &gt;&gt;&gt; createLeft ' '
--   "foobarbaz" :: Sized String 0 6 "foobar" &gt;&gt;&gt; createLeft '@'
--   "foobarbaz" :: Sized String 12 20 "foobarbaz@@@"
createLeft :: forall a l u. (IsSizedText a, KnownNat l, KnownNat u) => Elem a -> a -> Sized a l u

-- | Just like <a>createLeft</a>, except that elements on the right are
--   preferred. &gt;&gt;&gt; createRight '@' "foobarbaz" :: Sized String 0
--   6 "barbaz" &gt;&gt;&gt; createRight <tt>#</tt> "foobarbaz" :: Sized
--   String 12 20 "###foobarbaz"
createRight :: forall a l u. (IsSizedText a, KnownNat l, KnownNat u) => Elem a -> a -> Sized a l u

-- | Type-safe Sized constructor macros for string literals.
--   
--   Example:
--   
--   <pre>
--   $(sz "Foobar")
--   </pre>
--   
--   compiles to
--   
--   <pre>
--   unsafeCreate "Foobar" :: forall a. (IsString a, IsSizedText a) =&gt; Sized a 0 6
--   </pre>
--   
--   where 6 is the string length obtained at compile time.
sz :: LitS -> Q Exp

-- | Attempt to safely create a Sized if it matches target length.
--   
--   <pre>
--   &gt;&gt;&gt; create "foobar" :: Maybe (Sized String 6 10)
--   Just "foobar"
--   
--   &gt;&gt;&gt; create "barbaz" :: Maybe (Sized String 0 4)
--   Nothing
--   </pre>
--   
--   This is safer than <a>unsafeCreate</a> and unlike with
--   <a>createLeft</a> <a>createRight</a> the source value is left
--   unchanged. However, this implies a further run-time check for Nothing
--   values.
create :: forall a (l :: Nat) (u :: Nat). (IsSizedText a, KnownNat l, KnownNat u) => a -> Maybe (Sized a l u)

-- | Construct a new C.Sized of maximum length from a basic element.
--   
--   <pre>
--   &gt;&gt;&gt; replicate '=' :: C.Sized String 5 10
--   "=========="
--   </pre>
replicate :: forall a l u. (IsSizedText a, KnownNat l, KnownNat u) => Elem a -> Sized a l u

-- | Append two C.Sizeds together.
--   
--   <pre>
--   &gt;&gt;&gt; :set -Wno-type-defaults
--   
--   &gt;&gt;&gt; :type append $(sz "foo") $(st "bear")
--   append $(sz "foo") $(st "bear")
--     :: (C.IsSizedText a, IsString a) =&gt; C.Sized a 4 7
--   
--   &gt;&gt;&gt; append $(sz "foo") $(st "bear")
--   "foobear"
--   
--   &gt;&gt;&gt; :type append $(st "Hello, ") $(sz "world!")
--   append $(st "Hello, ") $(sz "world!")
--     :: (C.IsSizedText a, IsString a) =&gt; C.Sized a 7 13
--   
--   &gt;&gt;&gt; append $(st "Hello, ") $(sz "world!")
--   "Hello, world!"
--   </pre>
append :: forall a l1 u1 l2 u2. (IsSizedText a, KnownNat l1, KnownNat u1, KnownNat l2, KnownNat u2) => Sized a l1 u1 -> Sized a l2 u2 -> Sized a (l1 + l2) (u1 + u2)

-- | Reduce C.Sized length, preferring elements on the left.
--   
--   <pre>
--   &gt;&gt;&gt; take $(sz "Foobar") :: C.Sized String 0 3
--   "Foo"
--   </pre>
take :: forall a l1 u1 l2 u2. (IsSizedText a, KnownNat l1, KnownNat u1, KnownNat l2, KnownNat u2, l2 <= l1) => Sized a l1 u1 -> Sized a l2 u2

-- | Reduce C.Sized length, preferring elements on the right.
--   
--   <pre>
--   &gt;&gt;&gt; drop $(st "Foobar") :: C.Sized String 2 2
--   "ar"
--   
--   &gt;&gt;&gt; drop $(sz "Foobar") :: C.Sized String 0 2
--   "ar"
--   </pre>
drop :: forall a l1 u1 l2 u2. (IsSizedText a, KnownNat l1, KnownNat u1, KnownNat l2, KnownNat u2, l2 <= l1) => Sized a l1 u1 -> Sized a l2 u2

-- | Map a C.Sized to a C.Sized of the same length.
--   
--   <pre>
--   &gt;&gt;&gt; map toUpper $(st "Hello") :: C.Sized String 5 5
--   "HELLO"
--   </pre>
map :: IsSizedText a => (Elem a -> Elem a) -> Sized a l u -> Sized a l u

-- | Fill a C.Sized with extra elements up to target length, padding
--   original elements to the left.
padLeft :: forall a l1 u1 l2 u2. (IsSizedText a, KnownNat l1, KnownNat u1, KnownNat l2, KnownNat u2, KnownNat (u2 + u1), l2 <= l1, u1 <= u2) => Elem a -> Sized a l1 u1 -> Sized a l2 u2

-- | Like <a>padLeft</a>, but original elements are padded to the right.
padRight :: forall a l1 u1 l2 u2. (IsSizedText a, KnownNat l1, KnownNat u1, KnownNat l2, KnownNat u2, KnownNat (u1 + u2), l2 <= l1, u1 <= u2) => Elem a -> Sized a l1 u1 -> Sized a l2 u2

-- | Obtain length bounds from the type.
bounds :: forall a l u. (IsSizedText a, KnownNat l, KnownNat u) => Sized a l u -> (Int, Int)

-- | Obtain value-level length. Consult the actual data value.
length :: forall a l u. (IsSizedText a, KnownNat l, KnownNat u) => Sized a l u -> Int

-- | Data family which wraps values of the underlying type giving them a
--   type-level length. <tt>Sized t 6 10</tt> means a value of type
--   <tt>t</tt> of length between 6 and 10.
data family Sized a (l :: Nat) (u :: Nat)

-- | Class of types which can be assigned a type-level minimum and maximum
--   length.
class IsSizedText a where {
    
    -- | Basic element type. For <tt>IsSizedText [a]</tt>, this is <tt>a</tt>.
    type family Elem a;
}

-- | Simply wrap a value in a Sized as is, assuming any length.
--   
--   <b>WARNING</b> Use it only when you know what you're doing.
--   
--   For example, an expression like
--   
--   <pre>
--   unsafeCreate "somestring" :: Sized String 50 100
--   </pre>
--   
--   will typecheck, although the stored length information will not match
--   actual string size. This may result in wrong behaviour of all
--   functions defined for <a>IsSizedText</a>.
--   
--   When writing new <a>IsSizedText</a> instances, make this simply apply
--   the constructor of <a>Sized</a>.
unsafeCreate :: IsSizedText a => a -> Sized a l u

-- | Forget type-level minimum and maximum length, obtaining the underlying
--   value.
unwrap :: IsSizedText a => Sized a l u -> a
instance (Data.String.IsString a, Data.SizedText.Class.IsSizedText a, GHC.TypeNats.KnownNat l, GHC.TypeNats.KnownNat u) => Data.String.IsString (Data.SizedText.Class.Sized a l u)


-- | Git info appended to a version string
module Extras.GitVersion

-- | Generate a string like <tt>feature/foo 12c45b7 (dirty)</tt>.
--   
--   <tt>$(gitVersion …)</tt> <tt>::</tt> <tt>String</tt>
gitBranch :: Q Exp

-- | Generate a string like <tt>Version 1.2 [feature/foo 12e45b7
--   (dirty)]</tt>.
--   
--   <tt>$(gitVersion …)</tt> <tt>::</tt> <tt>String</tt>
gitVersion :: Version -> Q Exp

-- | Generate a string like <tt>Version 1.2)</tt>.
--   
--   <tt>$(plainVersion …)</tt> <tt>::</tt> <tt>String</tt>
plainVersion :: Version -> Q Exp


-- | Conversions for numbers used in tokens.
module Extras.Integral
rollUp :: Bits a => (Word8 -> a) -> (Word8, ByteString) -> a
byteStringToNatural :: ByteString -> Natural
byteStringToInteger :: ByteString -> Integer
naturalToByteString :: Natural -> ByteString

-- | Type-level to value-level for all Integrals, from the Natural
intVal :: (Num b, KnownNat n) => Proxy n -> b
integerToByteString :: Integer -> ByteString
word8 :: Integral a => a -> Word8
char :: Word8 -> Char
ordw :: Char -> Word8
byte :: Integral a => a -> Word8
int :: Integral a => a -> Int
integer :: Integral a => a -> Integer
natural :: Integral a => a -> Natural
class IsByteString a
fromByteString :: IsByteString a => ByteString -> a
toByteString :: IsByteString a => a -> ByteString
instance Extras.Integral.IsByteString GHC.Integer.Type.Integer
instance Extras.Integral.IsByteString GHC.Natural.Natural


-- | Hex encode/decoding.
module Extras.Hex
hexDigit :: Word8 -> Char
hexDigits :: String
hexValue :: Char -> Maybe Word8
hexWord8Syntax :: HasHex a => a -> String
class HasHex a
hex :: HasHex a => a -> String
fromHex :: HasHex a => String -> Maybe a
instance Extras.Hex.HasHex GHC.Word.Word8
instance Extras.Hex.HasHex GHC.Types.Char
instance Extras.Hex.HasHex [GHC.Word.Word8]
instance Extras.Hex.HasHex Data.ByteString.Internal.ByteString
instance Extras.Hex.HasHex GHC.Base.String
instance Extras.Hex.HasHex Data.ByteString.Short.Internal.ShortByteString
instance GHC.TypeNats.KnownNat n => Extras.Hex.HasHex (Data.StaticText.Class.Static Data.ByteString.Short.Internal.ShortByteString n)


-- | Datatypes for Tokens.
module Extras.Sized
data Fixed_bytes (n :: Nat)
Fixed_bytes :: !Static ShortByteString n -> Fixed_bytes (n :: Nat)
take :: (KnownNat m, KnownNat n, n <= m) => Fixed_bytes m -> Fixed_bytes n
drop :: (KnownNat m, KnownNat n, n <= m) => Fixed_bytes m -> Fixed_bytes n
append :: Fixed_bytes m -> Fixed_bytes n -> Fixed_bytes (m + n)

-- | HasFixed_bytes class and instances for conversion to/from Fixed_bytes
--   n
class (KnownNat n) => HasFixed_bytes n a
toFixed_bytes :: HasFixed_bytes n a => a -> Fixed_bytes n
fromFixed_bytes :: HasFixed_bytes n a => Fixed_bytes n -> a

-- | T.Static S.ShortByteString n methods lifted to Fixed_bytes n
fpack :: KnownNat n => ByteString -> Fixed_bytes n
funpack :: KnownNat n => Fixed_bytes n -> ByteString
instance GHC.Classes.Ord (Extras.Sized.Fixed_bytes n)
instance GHC.Classes.Eq (Extras.Sized.Fixed_bytes n)
instance GHC.TypeNats.KnownNat n => Extras.Sized.HasFixed_bytes n GHC.Natural.Natural
instance GHC.TypeNats.KnownNat n => Extras.Sized.HasFixed_bytes n (Data.StaticText.Class.Static Data.ByteString.Short.Internal.ShortByteString n)
instance GHC.TypeNats.KnownNat n => Extras.Sized.HasFixed_bytes n Data.ByteString.Short.Internal.ShortByteString
instance GHC.TypeNats.KnownNat n => Extras.Sized.HasFixed_bytes n Data.ByteString.Internal.ByteString
instance GHC.TypeNats.KnownNat n => Extras.Sized.HasFixed_bytes n [GHC.Word.Word8]
instance GHC.TypeNats.KnownNat n => Test.QuickCheck.Arbitrary.Arbitrary (Extras.Sized.Fixed_bytes n)
instance GHC.TypeNats.KnownNat n => GHC.Show.Show (Extras.Sized.Fixed_bytes n)
instance GHC.TypeNats.KnownNat n => Data.String.IsString (Extras.Sized.Fixed_bytes n)
instance GHC.TypeNats.KnownNat n => Extras.Hex.HasHex (Extras.Sized.Fixed_bytes n)


-- | Datatypes for <tt>hsed</tt> main. Constructors and lenses.
module Hsed.App

-- | Command line arguments
newtype Options
Options :: Bool -> Options
[_verbose] :: Options -> Bool
verbose :: Iso' Options Bool

-- | Global command environment
data App
App :: !LogFunc -> !ProcessContext -> !Options -> App
[_logFunc] :: App -> !LogFunc
[_processContext] :: App -> !ProcessContext
[_options] :: App -> !Options
processContext :: Lens' App ProcessContext
options :: Lens' App Options
logFunc :: Lens' App LogFunc
makeApp :: LogFunc -> ProcessContext -> Options -> App
instance RIO.Prelude.Logger.HasLogFunc Hsed.App.App
instance GHC.Show.Show Hsed.App.Options


-- | Parse and generate stream items.
module System.SED.Common.StreamItem
class StreamItem a
parser :: StreamItem a => Parser a
generate :: StreamItem a => a -> ByteString
parseByteString :: StreamItem a => ByteString -> Either String a
parseString :: StreamItem a => String -> Either String a
maybeParse :: StreamItem a => ByteString -> Maybe a

-- | reduction to canonical form; should never fail by returning Nothing
pg :: StreamItem a => a -> Maybe a
typeIsa :: StreamItem a => a -> a
type Parser = Parser ByteString
require :: (StreamItem a, Show a, Eq a) => a -> Parser a
instance System.SED.Common.StreamItem.StreamItem a => System.SED.Common.StreamItem.StreamItem [a]
instance System.SED.Common.StreamItem.StreamItem a => System.SED.Common.StreamItem.StreamItem (a, a)


-- | Datatypes for Tokens.
module System.SED.Common.Token
data Token
Unsigned :: Natural -> Token
Signed :: Integer -> Token
Bytes :: ByteString -> Token
ContinuedBytes :: ByteString -> Token
StartName :: Token
EndName :: Token
StartList :: Token
EndList :: Token
Call :: Token
EndOfData :: Token
EndOfSession :: Token
StartTransaction :: Token
EndTransaction :: Token
Empty :: Token
class (Show a) => IsToken a
fromToken :: IsToken a => Token -> Maybe a
token :: IsToken a => a -> Token
mtoken :: IsToken a => a -> Maybe Token
rawTokenSource :: MonadThrow m => ConduitT ByteString (PositionRange, Token) m ()
removeEmpty :: Monad m => ConduitT (PositionRange, Token) (PositionRange, Token) m ()
combineContinued :: Monad m => ConduitT (PositionRange, Token) (PositionRange, Token) m ()
tokenSource :: MonadThrow m => ConduitT ByteString (PositionRange, Token) m ()
instance GHC.Show.Show System.SED.Common.Token.Token
instance GHC.Classes.Eq System.SED.Common.Token.Token
instance System.SED.Common.Token.IsToken System.SED.Common.Token.Token
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Token.Token
instance Test.QuickCheck.Arbitrary.Arbitrary System.SED.Common.Token.Token


-- | Orphan instances.
module System.SED.Common.Instances
instance GHC.TypeNats.KnownNat n => System.SED.Common.Token.IsToken (Extras.Sized.Fixed_bytes n)
instance GHC.TypeNats.KnownNat n => System.SED.Common.StreamItem.StreamItem (Extras.Sized.Fixed_bytes n)


-- | Datatypes for UIDs and HalfUIDs.
module System.SED.Common.UID
showFixed_bytesHex :: KnownNat n => Fixed_bytes n -> [String]
showFixed_bytes :: KnownNat n => String -> Fixed_bytes n -> String
newtype HalfUID
HalfUID :: Fixed_bytes 4 -> HalfUID
halfUID :: Word8 -> Word8 -> Word8 -> Word8 -> HalfUID
newtype UID
UID :: Fixed_bytes 8 -> UID
uid :: Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> UID
uidUpper :: UID -> HalfUID
uidLower :: UID -> HalfUID
uidPlus :: HalfUID -> HalfUID -> UID
(+:+) :: HalfUID -> HalfUID -> UID
infix 9 +:+
hNull :: HalfUID
uNull :: UID
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.UID.UID
instance System.SED.Common.Token.IsToken System.SED.Common.UID.UID
instance GHC.Classes.Ord System.SED.Common.UID.UID
instance GHC.Classes.Eq System.SED.Common.UID.UID
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.UID.HalfUID
instance System.SED.Common.Token.IsToken System.SED.Common.UID.HalfUID
instance GHC.Classes.Ord System.SED.Common.UID.HalfUID
instance GHC.Classes.Eq System.SED.Common.UID.HalfUID
instance GHC.Show.Show System.SED.Common.UID.UID
instance Test.QuickCheck.Arbitrary.Arbitrary System.SED.Common.UID.UID
instance GHC.Show.Show System.SED.Common.UID.HalfUID
instance Test.QuickCheck.Arbitrary.Arbitrary System.SED.Common.UID.HalfUID


-- | Table
module System.SED.Common.Table
newtype TableName
TableName :: ByteString -> TableName
newtype TemplateName
TemplateName :: ByteString -> TemplateName
data Table
Table :: TableName -> HalfUID -> [TableColumn] -> [TableRow] -> Table
[_tableName] :: Table -> TableName
[_tableHalfUID] :: Table -> HalfUID
[_tableColumns] :: Table -> [TableColumn]
[_tableRows] :: Table -> [TableRow]
newtype TableRow
TableRow :: () -> TableRow
data TableColumn
TableColumn :: Int -> ByteString -> Bool -> ColumnType -> TableColumn
[_columnNumber] :: TableColumn -> Int
[_columnName] :: TableColumn -> ByteString
[_columnIsUnique] :: TableColumn -> Bool
[_columnType] :: TableColumn -> ColumnType
newtype ColumnType
ColumnType :: () -> ColumnType
instance GHC.Show.Show System.SED.Common.Table.Table
instance GHC.Classes.Eq System.SED.Common.Table.Table
instance GHC.Show.Show System.SED.Common.Table.TableColumn
instance GHC.Classes.Eq System.SED.Common.Table.TableColumn
instance GHC.Show.Show System.SED.Common.Table.ColumnType
instance GHC.Classes.Eq System.SED.Common.Table.ColumnType
instance GHC.Show.Show System.SED.Common.Table.TableRow
instance GHC.Classes.Eq System.SED.Common.Table.TableRow
instance Data.String.IsString System.SED.Common.Table.TemplateName
instance GHC.Classes.Eq System.SED.Common.Table.TemplateName
instance Data.String.IsString System.SED.Common.Table.TableName
instance GHC.Classes.Eq System.SED.Common.Table.TableName
instance GHC.Show.Show System.SED.Common.Table.TemplateName
instance GHC.Show.Show System.SED.Common.Table.TableName


-- | Template Haskell utilities.
module System.SED.Common.THUtil

-- | Run a table parser (any parser, really) producing a result or throwing
--   an error. This is safe only in TH code, where an error is a
--   compilation error.
parseTable :: Parser c -> String -> c

-- | Data declaration, essentially [d| data $n $c0 | $c1 ... deriving
--   ($d0,$d1,...) |]
dData :: Name -> [Name] -> [Name] -> Dec

-- | Signature declaration, essentially [d| $n :: $t |]
dSig :: Name -> Name -> Dec

-- | Value declaration, essentially [d| $n = $e |]
dVal :: Name -> Exp -> Dec

-- | HalfUID as Exp
eHalfUID :: HalfUID -> Exp

-- | UID as Exp
eUID :: UID -> Exp

-- | Wrap a Fixed_bytes n
eID :: KnownNat n => Name -> Fixed_bytes n -> Exp

-- | (Name, String) pair as Exp
eValP :: Name -> String -> Exp


-- | Special Purpose UIDs.
module System.SED.Common.SpecialPurposeUIDs

-- | Indicate that no object is being referenced.
uNULL :: UID

-- | For SP methods invoked within a session
uThisSP :: UID

-- | For methods invoked at the Session Manager Layer
uSMUID :: UID

uSMMethodUID :: Word8 -> UID

-- | For SP methods invoked within a session
uC_PINCharSetUnrestrictedUID :: UID
uProperties :: UID
uStartSession :: UID
uSyncSession :: UID
uStartTrustedSession :: UID
uSyncTrustedSession :: UID
uCloseSession :: UID


-- | Formats.
module System.SED.Common.Format
data Max_bytes :: Nat -> Type
data Core_table_kind
Object_Table :: Core_table_kind
Byte_Table :: Core_table_kind
newtype Core_uinteger_2
Core_uinteger_2 :: Int -> Core_uinteger_2
[fromCore_uinteger_2] :: Core_uinteger_2 -> Int
newtype Core_integer_2
Core_integer_2 :: Int -> Core_integer_2
[fromCore_integer_2] :: Core_integer_2 -> Int
newtype Core_uidref
Core_uidref :: UID -> Core_uidref
[fromCore_uidref] :: Core_uidref -> UID
newtype Core_max_bytes_32
Core_max_bytes_32 :: Max_bytes 32 -> Core_max_bytes_32
[fromCore_max_bytes_32] :: Core_max_bytes_32 -> Max_bytes 32
newtype Core_uidref_Base_Type
Core_uidref_Base_Type :: Core_uidref -> Core_uidref_Base_Type
newtype Core_uidref_non_Base_Type
Core_uidref_non_Base_Type :: Core_uidref -> Core_uidref_non_Base_Type
newtype Core_uidref_Byte_Table
Core_uidref_Byte_Table :: Core_uidref -> Core_uidref_Byte_Table
newtype Core_uidref_Object_Table
Core_uidref_Object_Table :: Core_uidref -> Core_uidref_Object_Table
data Known_Core_Type :: Nat -> Type
[Base_Type] :: Known_Core_Type 0
[Simple_Type] :: Core_uidref_Base_Type -> Core_uinteger_2 -> Known_Core_Type 1
[Enumeration_Type] :: [(Core_uinteger_2, Core_uinteger_2)] -> Known_Core_Type 2
[Alternative_Type] :: [Core_uidref_non_Base_Type] -> Known_Core_Type 3
[List_Type] :: Core_uinteger_2 -> Core_uidref_non_Base_Type -> Known_Core_Type 4
[Restricted_Reference_Type'5] :: [Core_uidref_Byte_Table] -> Known_Core_Type 5
[Restricted_Reference_Type'6] :: [Core_uidref_Object_Table] -> Known_Core_Type 6
[General_Reference_Type'7] :: Known_Core_Type 7
[General_Reference_Type'8] :: Known_Core_Type 8
[General_Reference_Type'9] :: Known_Core_Type 9
[General_Reference_Table_Type] :: Core_table_kind -> Known_Core_Type 10
[Named_Value_Name_Type] :: Core_max_bytes_32 -> Core_uidref_non_Base_Type -> Known_Core_Type 11
[Named_Value_Integer_Type] :: Core_integer_2 -> Core_uidref_non_Base_Type -> Known_Core_Type 12
[Named_Value_Uinteger_Type] :: Core_uinteger_2 -> Core_uidref_non_Base_Type -> Known_Core_Type 13
[Struct_Type] :: [Core_uidref_non_Base_Type] -> Known_Core_Type 14
[Set_Type] :: [(Core_uinteger_2, Core_uinteger_2)] -> Known_Core_Type 15
data Some_Core_Type
Some_Core_Type :: Known_Core_Type n -> Some_Core_Type
instance GHC.Show.Show System.SED.Common.Format.Core_uidref_Object_Table
instance GHC.Classes.Eq System.SED.Common.Format.Core_uidref_Object_Table
instance GHC.Show.Show System.SED.Common.Format.Core_uidref_Byte_Table
instance GHC.Classes.Eq System.SED.Common.Format.Core_uidref_Byte_Table
instance GHC.Show.Show System.SED.Common.Format.Core_uidref_non_Base_Type
instance GHC.Classes.Eq System.SED.Common.Format.Core_uidref_non_Base_Type
instance GHC.Show.Show System.SED.Common.Format.Core_uidref_Base_Type
instance GHC.Classes.Eq System.SED.Common.Format.Core_uidref_Base_Type
instance GHC.Show.Show System.SED.Common.Format.Core_max_bytes_32
instance GHC.Classes.Eq System.SED.Common.Format.Core_max_bytes_32
instance GHC.Show.Show System.SED.Common.Format.Core_uidref
instance GHC.Classes.Eq System.SED.Common.Format.Core_uidref
instance GHC.Show.Show System.SED.Common.Format.Core_integer_2
instance GHC.Classes.Eq System.SED.Common.Format.Core_integer_2
instance GHC.Show.Show System.SED.Common.Format.Core_uinteger_2
instance GHC.Classes.Eq System.SED.Common.Format.Core_uinteger_2
instance GHC.Show.Show System.SED.Common.Format.Core_table_kind
instance GHC.Classes.Eq System.SED.Common.Format.Core_table_kind
instance GHC.Enum.Enum System.SED.Common.Format.Core_table_kind
instance GHC.Show.Show (System.SED.Common.Format.Max_bytes n)
instance GHC.Classes.Eq (System.SED.Common.Format.Max_bytes n)
instance GHC.Show.Show (System.SED.Common.Format.Known_Core_Type n)
instance GHC.Classes.Eq (System.SED.Common.Format.Known_Core_Type n)
instance GHC.Show.Show System.SED.Common.Format.Some_Core_Type
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Format.Some_Core_Type
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Format.Core_uidref_Object_Table
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Format.Core_uidref_Byte_Table
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Format.Core_uidref_non_Base_Type
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Format.Core_uidref_Base_Type
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Format.Core_max_bytes_32
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Format.Core_uidref
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Format.Core_integer_2
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Format.Core_uinteger_2
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Format.Core_table_kind


-- | Utilities
module System.SED.Common.Util

-- | Convert to a UID from a string of eight hex digit pairs divided by a
--   single space
--   
--   E.g. "01 02 03 04 05 06 07 08"
--   
--   Throws an error on any other input. This means that if used in a
--   quasiquoter, the malformed string will not compile.
hexUID :: ByteString -> UID

-- | Trim trailing whitespace from e.g. a field in a quasiquoted table
trimTrailingWhitespace :: ByteString -> ByteString


-- | TableUIDs Template Haskell.
module System.SED.Common.TableUIDs.TH

-- | Bespoke QuasiQuoter for Table 240
t240 :: QuasiQuoter
instance GHC.Show.Show System.SED.Common.TableUIDs.TH.UIDRowDecs
instance GHC.Classes.Eq System.SED.Common.TableUIDs.TH.UIDRowDecs
instance GHC.Classes.Eq System.SED.Common.TableUIDs.TH.UIDRow
instance GHC.Base.Semigroup System.SED.Common.TableUIDs.TH.UIDRowDecs
instance GHC.Base.Monoid System.SED.Common.TableUIDs.TH.UIDRowDecs


-- | Table UIDs as specified in Table 240.
--   
--   The specification for each table is translated to three constant
--   declarations. For instance, the information on the
--   <tt>AccessControl</tt> table becomes
--   
--   <pre>
--   --| The HalfUID that identifies the AccessControl table
--   hAccessControl :: HalfUID
--   hAccessControl = halfUID 0x00 0x00 0x00 0x07
--   
--   --| The UID that identifies the AccessControl table itself
--   uAccessControlTable :: UID
--   uAccessControlTable = uid 0x00 0x00 0x00 0x07 0x00 0x00 0x00 0x00
--   
--   --| The UID that identifies the AccessControl table entry in the Table Table
--   uAccessControlTableObject :: UID
--   uAccessControlTableObject = uid 0x00 0x00 0x00 0x01 0x00 0x00 0x00 0x07
--   </pre>
--   
--   Unfortunately, Template Haskell can neither see manual comments nor
--   create comments for Haddock to see; hence the names themselves must
--   suffice as documentation.
module System.SED.Common.TableUIDs
nameUID :: Map UID String
nameHalfUID :: Map HalfUID String
hTable :: HalfUID
uTableTable :: UID
uTableTableObject :: UID
hSPInfo :: HalfUID
uSPInfoTable :: UID
uSPInfoTableObject :: UID
hSPTemplates :: HalfUID
uSPTemplatesTable :: UID
uSPTemplatesTableObject :: UID
hColumn :: HalfUID
uColumnTable :: UID
uColumnTableObject :: UID
hType :: HalfUID
uTypeTable :: UID
uTypeTableObject :: UID
hMethodID :: HalfUID
uMethodIDTable :: UID
uMethodIDTableObject :: UID
hAccessControl :: HalfUID
uAccessControlTable :: UID
uAccessControlTableObject :: UID
hACE :: HalfUID
uACETable :: UID
uACETableObject :: UID
hAuthority :: HalfUID
uAuthorityTable :: UID
uAuthorityTableObject :: UID
hCertificates :: HalfUID
uCertificatesTable :: UID
uCertificatesTableObject :: UID
hC_PIN :: HalfUID
uC_PINTable :: UID
uC_PINTableObject :: UID
hC_RSA_1024 :: HalfUID
uC_RSA_1024Table :: UID
uC_RSA_1024TableObject :: UID
hC_RSA_2048 :: HalfUID
uC_RSA_2048Table :: UID
uC_RSA_2048TableObject :: UID
hC_AES_128 :: HalfUID
uC_AES_128Table :: UID
uC_AES_128TableObject :: UID
hC_AES_256 :: HalfUID
uC_AES_256Table :: UID
uC_AES_256TableObject :: UID
hC_EC_160 :: HalfUID
uC_EC_160Table :: UID
uC_EC_160TableObject :: UID
hC_EC_192 :: HalfUID
uC_EC_192Table :: UID
uC_EC_192TableObject :: UID
hC_EC_224 :: HalfUID
uC_EC_224Table :: UID
uC_EC_224TableObject :: UID
hC_EC_256 :: HalfUID
uC_EC_256Table :: UID
uC_EC_256TableObject :: UID
hC_EC_384 :: HalfUID
uC_EC_384Table :: UID
uC_EC_384TableObject :: UID
hC_EC_521 :: HalfUID
uC_EC_521Table :: UID
uC_EC_521TableObject :: UID
hC_EC_163 :: HalfUID
uC_EC_163Table :: UID
uC_EC_163TableObject :: UID
hC_EC_233 :: HalfUID
uC_EC_233Table :: UID
uC_EC_233TableObject :: UID
hC_EC_283 :: HalfUID
uC_EC_283Table :: UID
uC_EC_283TableObject :: UID
hC_HMAC_160 :: HalfUID
uC_HMAC_160Table :: UID
uC_HMAC_160TableObject :: UID
hC_HMAC_256 :: HalfUID
uC_HMAC_256Table :: UID
uC_HMAC_256TableObject :: UID
hC_HMAC_384 :: HalfUID
uC_HMAC_384Table :: UID
uC_HMAC_384TableObject :: UID
hC_HMAC_512 :: HalfUID
uC_HMAC_512Table :: UID
uC_HMAC_512TableObject :: UID
hSecretProtect :: HalfUID
uSecretProtectTable :: UID
uSecretProtectTableObject :: UID
hTPerInfo :: HalfUID
uTPerInfoTable :: UID
uTPerInfoTableObject :: UID
hCryptoSuite :: HalfUID
uCryptoSuiteTable :: UID
uCryptoSuiteTableObject :: UID
hTemplate :: HalfUID
uTemplateTable :: UID
uTemplateTableObject :: UID
hSP :: HalfUID
uSPTable :: UID
uSPTableObject :: UID
hClockTime :: HalfUID
uClockTimeTable :: UID
uClockTimeTableObject :: UID
hH_SHA_1 :: HalfUID
uH_SHA_1Table :: UID
uH_SHA_1TableObject :: UID
hH_SHA_256 :: HalfUID
uH_SHA_256Table :: UID
uH_SHA_256TableObject :: UID
hH_SHA_384 :: HalfUID
uH_SHA_384Table :: UID
uH_SHA_384TableObject :: UID
hH_SHA_512 :: HalfUID
uH_SHA_512Table :: UID
uH_SHA_512TableObject :: UID
hLog :: HalfUID
uLogTable :: UID
uLogTableObject :: UID
hLogList :: HalfUID
uLogListTable :: UID
uLogListTableObject :: UID
hLockingInfo :: HalfUID
uLockingInfoTable :: UID
uLockingInfoTableObject :: UID
hLocking :: HalfUID
uLockingTable :: UID
uLockingTableObject :: UID
hMBRControl :: HalfUID
uMBRControlTable :: UID
uMBRControlTableObject :: UID
hMBR :: HalfUID
uMBRTable :: UID
uMBRTableObject :: UID
hK_AES_128 :: HalfUID
uK_AES_128Table :: UID
uK_AES_128TableObject :: UID
hK_AES_256 :: HalfUID
uK_AES_256Table :: UID
uK_AES_256TableObject :: UID

-- | Look up the name of a Table <a>HalfUID</a>
lookupTableHalfUID :: HalfUID -> Maybe String

-- | Look up the name of a Table <a>UID</a> or a Table object <a>UID</a>
lookupTableUID :: UID -> Maybe String


-- | Template Haskell for parsing Table column types in Section 5.1.3.
module System.SED.Common.ColumnTypes.TH

-- | QuasiQuoter for Type Table row tables.
--   
--   Each row of the Type Table is in its own table in the Core Spec.
ttype :: QuasiQuoter
ttypeDecs :: String -> [Dec]
typeTableParser :: Parser TypeTableRow
typeTableRow :: [Int] -> Parser TypeTableRow
dTypeTableRow :: TypeTableRow -> TypeTableRowDecs
typeTableTitle :: Parser ByteString
spaces :: Parser ByteString
rowSepFieldLengths :: Parser [Int]
rowSep :: Parser [Int]
blankLines :: Parser ()
tableRowFields :: [Int] -> Parser [ByteString]
data TypeTableRow
TypeTableRow :: TypeUIDField -> TypeName -> [FormatString] -> TypeTableRow
type TypeUIDField = ByteString
type TypeName = ByteString
type FormatString = ByteString
header :: [Int] -> Parser ()
formatString :: TypeTableRow -> ByteString
newtype TypeTableRowDecs
TypeTableRowDecs :: [Dec] -> TypeTableRowDecs

-- | QuasiQuoter for Type Table enum tables.
--   
--   Some enumerations are explicated by tables following the Type Tables
--   that refer to them.
tenum :: QuasiQuoter
tenumDecs :: String -> [Dec]
dEnum :: (String, [EnumRow]) -> [Dec]
enumTableParser :: Parser (String, [EnumRow])
data EnumRow
EnumRow :: String -> [Int] -> EnumRow
enumTableTitle :: Parser String
enumTableRow :: [Int] -> Parser EnumRow
instance GHC.Show.Show System.SED.Common.ColumnTypes.TH.EnumRow
instance GHC.Show.Show System.SED.Common.ColumnTypes.TH.TypeTableRowDecs
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.TH.TypeTableRowDecs
instance GHC.Show.Show System.SED.Common.ColumnTypes.TH.TypeTableRow
instance GHC.Base.Semigroup System.SED.Common.ColumnTypes.TH.TypeTableRowDecs
instance GHC.Base.Monoid System.SED.Common.ColumnTypes.TH.TypeTableRowDecs
instance GHC.Base.Semigroup System.SED.Common.ColumnTypes.TH.TypeTableRow


-- | Table column types.
module System.SED.Common.ColumnTypes
uAC_elementType :: UID
uACE_columnsType :: UID
uACE_expressionType :: UID
uACE_object_refType :: UID
uACLType :: UID
uadv_key_modeType :: UID
data Core_adv_key_mode
Core_adv_key_mode_Wait_for_AdvKey_Req :: Core_adv_key_mode
Core_adv_key_mode_Auto_advance_keys :: Core_adv_key_mode
Core_adv_key_mode_Reserved :: Core_adv_key_mode
Core_adv_key_mode_Reserved_3 :: Core_adv_key_mode
Core_adv_key_mode_Reserved_4 :: Core_adv_key_mode
Core_adv_key_mode_Reserved_5 :: Core_adv_key_mode
Core_adv_key_mode_Reserved_6 :: Core_adv_key_mode
Core_adv_key_mode_Reserved_7 :: Core_adv_key_mode
uattr_flagsType :: UID
data Core_attr_flags
Core_attr_flags_Get_Not_Permitted :: Core_attr_flags
Core_attr_flags_Set_Not_Permitted :: Core_attr_flags
Core_attr_flags_Reserved :: Core_attr_flags
Core_attr_flags_Reserved_3 :: Core_attr_flags
Core_attr_flags_Reserved_4 :: Core_attr_flags
Core_attr_flags_Reserved_5 :: Core_attr_flags
Core_attr_flags_Reserved_6 :: Core_attr_flags
Core_attr_flags_Reserved_7 :: Core_attr_flags
Core_attr_flags_Reserved_8 :: Core_attr_flags
Core_attr_flags_Reserved_9 :: Core_attr_flags
Core_attr_flags_Reserved_10 :: Core_attr_flags
Core_attr_flags_Reserved_11 :: Core_attr_flags
Core_attr_flags_Reserved_12 :: Core_attr_flags
Core_attr_flags_Reserved_13 :: Core_attr_flags
Core_attr_flags_Reserved_14 :: Core_attr_flags
Core_attr_flags_Reserved_15 :: Core_attr_flags
Core_attr_flags_Reserved_16 :: Core_attr_flags
Core_attr_flags_Reserved_17 :: Core_attr_flags
Core_attr_flags_Reserved_18 :: Core_attr_flags
Core_attr_flags_Reserved_19 :: Core_attr_flags
Core_attr_flags_Reserved_20 :: Core_attr_flags
Core_attr_flags_Reserved_21 :: Core_attr_flags
Core_attr_flags_Reserved_22 :: Core_attr_flags
Core_attr_flags_Reserved_23 :: Core_attr_flags
Core_attr_flags_Reserved_24 :: Core_attr_flags
Core_attr_flags_Reserved_25 :: Core_attr_flags
Core_attr_flags_Reserved_26 :: Core_attr_flags
Core_attr_flags_Reserved_27 :: Core_attr_flags
Core_attr_flags_Reserved_28 :: Core_attr_flags
Core_attr_flags_Reserved_29 :: Core_attr_flags
Core_attr_flags_Reserved_30 :: Core_attr_flags
Core_attr_flags_Reserved_31 :: Core_attr_flags
uauth_methodType :: UID
data Core_auth_method
Core_auth_method_None :: Core_auth_method
Core_auth_method_Password :: Core_auth_method
Core_auth_method_Exchange :: Core_auth_method
Core_auth_method_Sign :: Core_auth_method
Core_auth_method_SymK :: Core_auth_method
Core_auth_method_HMAC :: Core_auth_method
Core_auth_method_TPerSign :: Core_auth_method
Core_auth_method_TPerExchange :: Core_auth_method
Core_auth_method_Reserved :: Core_auth_method
Core_auth_method_Reserved_9 :: Core_auth_method
Core_auth_method_Reserved_10 :: Core_auth_method
Core_auth_method_Reserved_11 :: Core_auth_method
Core_auth_method_Reserved_12 :: Core_auth_method
Core_auth_method_Reserved_13 :: Core_auth_method
Core_auth_method_Reserved_14 :: Core_auth_method
Core_auth_method_Reserved_15 :: Core_auth_method
Core_auth_method_Reserved_16 :: Core_auth_method
Core_auth_method_Reserved_17 :: Core_auth_method
Core_auth_method_Reserved_18 :: Core_auth_method
Core_auth_method_Reserved_19 :: Core_auth_method
Core_auth_method_Reserved_20 :: Core_auth_method
Core_auth_method_Reserved_21 :: Core_auth_method
Core_auth_method_Reserved_22 :: Core_auth_method
Core_auth_method_Reserved_23 :: Core_auth_method
uAuthority_object_refType :: UID
ubooleanType :: UID
data Core_boolean
Core_boolean_False :: Core_boolean
Core_boolean_True :: Core_boolean
uboolean_ACEType :: UID
data Core_boolean_ACE
Core_boolean_ACE_And :: Core_boolean_ACE
Core_boolean_ACE_Or :: Core_boolean_ACE
Core_boolean_ACE_Not :: Core_boolean_ACE
ubyte_row_refType :: UID
ubyte_table_refType :: UID
ubytesType :: UID
ubytes_4Type :: UID
ubytes_12Type :: UID
ubytes_16Type :: UID
ubytes_20Type :: UID
ubytes_32Type :: UID
ubytes_48Type :: UID
ubytes_64Type :: UID
uCertificates_object_refType :: UID
uclock_kindType :: UID
data Core_clock_kind
Core_clock_kind_Timer :: Core_clock_kind
Core_clock_kind_Low :: Core_clock_kind
Core_clock_kind_High :: Core_clock_kind
Core_clock_kind_LowAndHigh :: Core_clock_kind
uclock_timeType :: UID
uColumn_object_refType :: UID
ucred_object_uidrefType :: UID
udateType :: UID
uDayType :: UID
uday_enumType :: UID
uenc_supportedType :: UID
data Core_enc_supported
Core_enc_supported_None :: Core_enc_supported
Core_enc_supported_Media_Encryption :: Core_enc_supported
Core_enc_supported_Reserved :: Core_enc_supported
Core_enc_supported_Reserved_3 :: Core_enc_supported
Core_enc_supported_Reserved_4 :: Core_enc_supported
Core_enc_supported_Reserved_5 :: Core_enc_supported
Core_enc_supported_Reserved_6 :: Core_enc_supported
Core_enc_supported_Reserved_7 :: Core_enc_supported
Core_enc_supported_Reserved_8 :: Core_enc_supported
Core_enc_supported_Reserved_9 :: Core_enc_supported
Core_enc_supported_Reserved_10 :: Core_enc_supported
Core_enc_supported_Reserved_11 :: Core_enc_supported
Core_enc_supported_Reserved_12 :: Core_enc_supported
Core_enc_supported_Reserved_13 :: Core_enc_supported
Core_enc_supported_Reserved_14 :: Core_enc_supported
Core_enc_supported_Reserved_15 :: Core_enc_supported
ufeedback_sizeType :: UID
uFractionType :: UID
ufraction_enumType :: UID
ugen_statusType :: UID
uhash_protocolType :: UID
data Core_hash_protocol
Core_hash_protocol_None :: Core_hash_protocol
Core_hash_protocol_SHA_1 :: Core_hash_protocol
Core_hash_protocol_SHA_256 :: Core_hash_protocol
Core_hash_protocol_SHA_384 :: Core_hash_protocol
Core_hash_protocol_SHA_512 :: Core_hash_protocol
Core_hash_protocol_Reserved :: Core_hash_protocol
Core_hash_protocol_Reserved_6 :: Core_hash_protocol
Core_hash_protocol_Reserved_7 :: Core_hash_protocol
Core_hash_protocol_Reserved_8 :: Core_hash_protocol
Core_hash_protocol_Reserved_9 :: Core_hash_protocol
Core_hash_protocol_Reserved_10 :: Core_hash_protocol
Core_hash_protocol_Reserved_11 :: Core_hash_protocol
Core_hash_protocol_Reserved_12 :: Core_hash_protocol
Core_hash_protocol_Reserved_13 :: Core_hash_protocol
Core_hash_protocol_Reserved_14 :: Core_hash_protocol
Core_hash_protocol_Reserved_15 :: Core_hash_protocol
uHourType :: UID
uhour_enumType :: UID
uintegerType :: UID
uinteger_1Type :: UID
uinteger_2Type :: UID
ukey_128Type :: UID
ukey_256Type :: UID
ukeys_avail_condsType :: UID
data Core_keys_avail_conds
Core_keys_avail_conds_None :: Core_keys_avail_conds
Core_keys_avail_conds_Authentication_of_an_authority_with_Set_access_to_any_of_the_ReadLockedWriteLocked_ReadLockEnabled_or_WriteLockEnabled_columns_for_that_LBA_range :: Core_keys_avail_conds
Core_keys_avail_conds_Reserved :: Core_keys_avail_conds
Core_keys_avail_conds_Reserved_3 :: Core_keys_avail_conds
Core_keys_avail_conds_Reserved_4 :: Core_keys_avail_conds
Core_keys_avail_conds_Reserved_5 :: Core_keys_avail_conds
Core_keys_avail_conds_Reserved_6 :: Core_keys_avail_conds
Core_keys_avail_conds_Reserved_7 :: Core_keys_avail_conds
ulagType :: UID
ulast_reenc_statType :: UID
data Core_last_reenc_stat
Core_last_reenc_stat_Success :: Core_last_reenc_stat
Core_last_reenc_stat_Read_Error :: Core_last_reenc_stat
Core_last_reenc_stat_Write_Error :: Core_last_reenc_stat
Core_last_reenc_stat_Verify_Error :: Core_last_reenc_stat
Core_last_reenc_stat_Reserved :: Core_last_reenc_stat
Core_last_reenc_stat_Reserved_5 :: Core_last_reenc_stat
Core_last_reenc_stat_Reserved_6 :: Core_last_reenc_stat
Core_last_reenc_stat_Reserved_7 :: Core_last_reenc_stat
ulife_cycle_stateType :: UID
data Core_life_cycle_state
Core_life_cycle_state_Issued :: Core_life_cycle_state
Core_life_cycle_state_Issued_Disabled :: Core_life_cycle_state
Core_life_cycle_state_Issued_Frozen :: Core_life_cycle_state
Core_life_cycle_state_Issued_Disabled_Frozen :: Core_life_cycle_state
Core_life_cycle_state_Issued_Failed :: Core_life_cycle_state
Core_life_cycle_state_Unassigned :: Core_life_cycle_state
Core_life_cycle_state_Unassigned_6 :: Core_life_cycle_state
Core_life_cycle_state_Unassigned_7 :: Core_life_cycle_state
Core_life_cycle_state_Unassigned_14 :: Core_life_cycle_state
Core_life_cycle_state_Unassigned_15 :: Core_life_cycle_state
Core_life_cycle_state_Reserved_for_SSC_Usage :: Core_life_cycle_state
Core_life_cycle_state_Reserved_for_SSC_Usage_9 :: Core_life_cycle_state
Core_life_cycle_state_Reserved_for_SSC_Usage_10 :: Core_life_cycle_state
Core_life_cycle_state_Reserved_for_SSC_Usage_11 :: Core_life_cycle_state
Core_life_cycle_state_Reserved_for_SSC_Usage_12 :: Core_life_cycle_state
Core_life_cycle_state_Reserved_for_SSC_Usage_13 :: Core_life_cycle_state
uLogList_object_refType :: UID
ulog_row_refType :: UID
ulog_selectType :: UID
data Core_log_select
Core_log_select_None :: Core_log_select
Core_log_select_LogSuccess :: Core_log_select
Core_log_select_LogFail :: Core_log_select
Core_log_select_LogAlways :: Core_log_select
umax_bytesType :: UID
umax_bytes_32Type :: UID
umax_bytes_64Type :: UID
umediakey_object_uidrefType :: UID
uMethodID_object_refType :: UID
umessaging_typeType :: UID
uMinuteType :: UID
uminute_enumType :: UID
uMonthType :: UID
umonth_enumType :: UID
unameType :: UID
uobject_refType :: UID
upadding_typeType :: UID
data Core_padding_type
Core_padding_type_None :: Core_padding_type
Core_padding_type_None_1 :: Core_padding_type
Core_padding_type_RSAES_PKCS1_v1_5 :: Core_padding_type
Core_padding_type_RSAES_OAEP :: Core_padding_type
Core_padding_type_RSASSA_PKCS1_v1_5 :: Core_padding_type
Core_padding_type_Reserved :: Core_padding_type
Core_padding_type_Reserved_6 :: Core_padding_type
Core_padding_type_Reserved_7 :: Core_padding_type
Core_padding_type_Reserved_8 :: Core_padding_type
Core_padding_type_Reserved_9 :: Core_padding_type
Core_padding_type_Reserved_10 :: Core_padding_type
Core_padding_type_Reserved_11 :: Core_padding_type
Core_padding_type_Reserved_12 :: Core_padding_type
Core_padding_type_Reserved_13 :: Core_padding_type
Core_padding_type_Reserved_14 :: Core_padding_type
Core_padding_type_Reserved_15 :: Core_padding_type
upasswordType :: UID
uprotect_typesType :: UID
ureencrypt_requestType :: UID
ureencrypt_stateType :: UID
data Core_reencrypt_state
Core_reencrypt_state_NA :: Core_reencrypt_state
Core_reencrypt_state_Idle :: Core_reencrypt_state
Core_reencrypt_state_Pending :: Core_reencrypt_state
Core_reencrypt_state_Active :: Core_reencrypt_state
Core_reencrypt_state_Completed :: Core_reencrypt_state
Core_reencrypt_state_Paused :: Core_reencrypt_state
Core_reencrypt_state_Reserved :: Core_reencrypt_state
Core_reencrypt_state_Reserved_7 :: Core_reencrypt_state
Core_reencrypt_state_Reserved_8 :: Core_reencrypt_state
Core_reencrypt_state_Reserved_9 :: Core_reencrypt_state
Core_reencrypt_state_Reserved_10 :: Core_reencrypt_state
Core_reencrypt_state_Reserved_11 :: Core_reencrypt_state
Core_reencrypt_state_Reserved_12 :: Core_reencrypt_state
Core_reencrypt_state_Reserved_13 :: Core_reencrypt_state
Core_reencrypt_state_Reserved_14 :: Core_reencrypt_state
Core_reencrypt_state_Reserved_15 :: Core_reencrypt_state
Core_reencrypt_state_Reserved_16 :: Core_reencrypt_state
ureset_typesType :: UID
data Core_reset_types
Core_reset_types_Power_Cycle :: Core_reset_types
Core_reset_types_Hardware :: Core_reset_types
Core_reset_types_HotPlug :: Core_reset_types
Core_reset_types_Reserved :: Core_reset_types
Core_reset_types_Reserved_4 :: Core_reset_types
Core_reset_types_Reserved_5 :: Core_reset_types
Core_reset_types_Reserved_6 :: Core_reset_types
Core_reset_types_Reserved_7 :: Core_reset_types
Core_reset_types_Reserved_8 :: Core_reset_types
Core_reset_types_Reserved_9 :: Core_reset_types
Core_reset_types_Reserved_10 :: Core_reset_types
Core_reset_types_Reserved_11 :: Core_reset_types
Core_reset_types_Reserved_12 :: Core_reset_types
Core_reset_types_Reserved_13 :: Core_reset_types
Core_reset_types_Reserved_14 :: Core_reset_types
Core_reset_types_Reserved_15 :: Core_reset_types
Core_reset_types_Vendor_Unique :: Core_reset_types
Core_reset_types_Vendor_Unique_17 :: Core_reset_types
Core_reset_types_Vendor_Unique_18 :: Core_reset_types
Core_reset_types_Vendor_Unique_19 :: Core_reset_types
Core_reset_types_Vendor_Unique_20 :: Core_reset_types
Core_reset_types_Vendor_Unique_21 :: Core_reset_types
Core_reset_types_Vendor_Unique_22 :: Core_reset_types
Core_reset_types_Vendor_Unique_23 :: Core_reset_types
Core_reset_types_Vendor_Unique_24 :: Core_reset_types
Core_reset_types_Vendor_Unique_25 :: Core_reset_types
Core_reset_types_Vendor_Unique_26 :: Core_reset_types
Core_reset_types_Vendor_Unique_27 :: Core_reset_types
Core_reset_types_Vendor_Unique_28 :: Core_reset_types
Core_reset_types_Vendor_Unique_29 :: Core_reset_types
Core_reset_types_Vendor_Unique_30 :: Core_reset_types
Core_reset_types_Vendor_Unique_31 :: Core_reset_types
uSecondsType :: UID
useconds_enumType :: UID
uSPTemplates_object_refType :: UID
uSSCType :: UID
usymmetric_modeType :: UID
data Core_symmetric_mode
Core_symmetric_mode_ECB :: Core_symmetric_mode
Core_symmetric_mode_CBC :: Core_symmetric_mode
Core_symmetric_mode_CFB :: Core_symmetric_mode
Core_symmetric_mode_OFB :: Core_symmetric_mode
Core_symmetric_mode_GCM :: Core_symmetric_mode
Core_symmetric_mode_CTR :: Core_symmetric_mode
Core_symmetric_mode_CCM :: Core_symmetric_mode
Core_symmetric_mode_XTS :: Core_symmetric_mode
Core_symmetric_mode_LRW :: Core_symmetric_mode
Core_symmetric_mode_EME :: Core_symmetric_mode
Core_symmetric_mode_CMC :: Core_symmetric_mode
Core_symmetric_mode_XEX :: Core_symmetric_mode
Core_symmetric_mode_Reserved :: Core_symmetric_mode
Core_symmetric_mode_Reserved_13 :: Core_symmetric_mode
Core_symmetric_mode_Reserved_14 :: Core_symmetric_mode
Core_symmetric_mode_Reserved_15 :: Core_symmetric_mode
Core_symmetric_mode_Reserved_16 :: Core_symmetric_mode
Core_symmetric_mode_Reserved_17 :: Core_symmetric_mode
Core_symmetric_mode_Reserved_18 :: Core_symmetric_mode
Core_symmetric_mode_Reserved_19 :: Core_symmetric_mode
Core_symmetric_mode_Reserved_20 :: Core_symmetric_mode
Core_symmetric_mode_Reserved_21 :: Core_symmetric_mode
Core_symmetric_mode_Reserved_22 :: Core_symmetric_mode
Core_symmetric_mode_Reserved_23 :: Core_symmetric_mode
usymmetric_mode_mediaType :: UID
data Core_symmetric_mode_media
Core_symmetric_mode_media_ECB :: Core_symmetric_mode_media
Core_symmetric_mode_media_CBC :: Core_symmetric_mode_media
Core_symmetric_mode_media_CFB :: Core_symmetric_mode_media
Core_symmetric_mode_media_OFB :: Core_symmetric_mode_media
Core_symmetric_mode_media_GCM :: Core_symmetric_mode_media
Core_symmetric_mode_media_CTR :: Core_symmetric_mode_media
Core_symmetric_mode_media_CCM :: Core_symmetric_mode_media
Core_symmetric_mode_media_XTS :: Core_symmetric_mode_media
Core_symmetric_mode_media_LRW :: Core_symmetric_mode_media
Core_symmetric_mode_media_EME :: Core_symmetric_mode_media
Core_symmetric_mode_media_CMC :: Core_symmetric_mode_media
Core_symmetric_mode_media_XEX :: Core_symmetric_mode_media
Core_symmetric_mode_media_Reserved :: Core_symmetric_mode_media
Core_symmetric_mode_media_Reserved_13 :: Core_symmetric_mode_media
Core_symmetric_mode_media_Reserved_14 :: Core_symmetric_mode_media
Core_symmetric_mode_media_Reserved_15 :: Core_symmetric_mode_media
Core_symmetric_mode_media_Reserved_16 :: Core_symmetric_mode_media
Core_symmetric_mode_media_Reserved_17 :: Core_symmetric_mode_media
Core_symmetric_mode_media_Reserved_18 :: Core_symmetric_mode_media
Core_symmetric_mode_media_Reserved_19 :: Core_symmetric_mode_media
Core_symmetric_mode_media_Reserved_20 :: Core_symmetric_mode_media
Core_symmetric_mode_media_Reserved_21 :: Core_symmetric_mode_media
Core_symmetric_mode_media_Reserved_22 :: Core_symmetric_mode_media
Core_symmetric_mode_media_Media_Encryption :: Core_symmetric_mode_media
utable_kindType :: UID
data Core_table_kind
Core_table_kind_NA :: Core_table_kind
Core_table_kind_Object :: Core_table_kind
Core_table_kind_Byte :: Core_table_kind
Core_table_kind_Reserved :: Core_table_kind
Core_table_kind_Reserved_4 :: Core_table_kind
Core_table_kind_Reserved_5 :: Core_table_kind
Core_table_kind_Reserved_6 :: Core_table_kind
Core_table_kind_Reserved_7 :: Core_table_kind
Core_table_kind_Reserved_8 :: Core_table_kind
utable_or_object_refType :: UID
uTable_object_refType :: UID
utable_refType :: UID
uTemplate_object_refType :: UID
utype_defType :: UID
uType_object_refType :: UID
uuidType :: UID
uuintegerType :: UID
uuinteger_1Type :: UID
uuinteger_128Type :: UID
uuinteger_2Type :: UID
uuinteger_20Type :: UID
uuinteger_21Type :: UID
uuinteger_24Type :: UID
uuinteger_256Type :: UID
uuinteger_28Type :: UID
uuinteger_30Type :: UID
uuinteger_36Type :: UID
uuinteger_4Type :: UID
uuinteger_48Type :: UID
uuinteger_64Type :: UID
uuinteger_66Type :: UID
uuinteger_8Type :: UID
uverify_modeType :: UID
data Core_verify_mode
Core_verify_mode_No_verify :: Core_verify_mode
Core_verify_mode_Verify_enabled :: Core_verify_mode
Core_verify_mode_Reserved :: Core_verify_mode
Core_verify_mode_Reserved_3 :: Core_verify_mode
Core_verify_mode_Reserved_4 :: Core_verify_mode
Core_verify_mode_Reserved_5 :: Core_verify_mode
Core_verify_mode_Reserved_6 :: Core_verify_mode
Core_verify_mode_Reserved_7 :: Core_verify_mode
uYearType :: UID
uyear_enumType :: UID
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_verify_mode
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_verify_mode
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_verify_mode
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_verify_mode
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_verify_mode
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_table_kind
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_table_kind
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_table_kind
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_table_kind
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_table_kind
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_symmetric_mode_media
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_symmetric_mode_media
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_symmetric_mode_media
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_symmetric_mode_media
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_symmetric_mode_media
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_symmetric_mode
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_symmetric_mode
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_symmetric_mode
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_symmetric_mode
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_symmetric_mode
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_reset_types
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_reset_types
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_reset_types
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_reset_types
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_reset_types
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_reencrypt_state
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_reencrypt_state
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_reencrypt_state
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_reencrypt_state
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_reencrypt_state
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_padding_type
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_padding_type
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_padding_type
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_padding_type
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_padding_type
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_log_select
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_log_select
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_log_select
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_log_select
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_log_select
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_life_cycle_state
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_life_cycle_state
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_life_cycle_state
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_life_cycle_state
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_life_cycle_state
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_last_reenc_stat
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_last_reenc_stat
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_last_reenc_stat
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_last_reenc_stat
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_last_reenc_stat
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_keys_avail_conds
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_keys_avail_conds
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_keys_avail_conds
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_keys_avail_conds
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_keys_avail_conds
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_hash_protocol
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_hash_protocol
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_hash_protocol
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_hash_protocol
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_hash_protocol
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_enc_supported
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_enc_supported
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_enc_supported
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_enc_supported
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_enc_supported
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_clock_kind
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_clock_kind
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_clock_kind
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_clock_kind
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_clock_kind
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_boolean_ACE
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_boolean_ACE
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_boolean_ACE
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_boolean_ACE
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_boolean_ACE
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_boolean
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_boolean
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_boolean
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_boolean
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_boolean
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_auth_method
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_auth_method
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_auth_method
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_auth_method
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_auth_method
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_attr_flags
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_attr_flags
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_attr_flags
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_attr_flags
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_attr_flags
instance GHC.Show.Show System.SED.Common.ColumnTypes.Core_adv_key_mode
instance GHC.Classes.Ord System.SED.Common.ColumnTypes.Core_adv_key_mode
instance GHC.Classes.Eq System.SED.Common.ColumnTypes.Core_adv_key_mode
instance GHC.Enum.Enum System.SED.Common.ColumnTypes.Core_adv_key_mode
instance GHC.Enum.Bounded System.SED.Common.ColumnTypes.Core_adv_key_mode


-- | Datatypes for Tokens.
module System.SED.Common.Value
newtype Datum
Datum :: Token -> Datum
class (Show v) => IsDatum v
datum :: IsDatum v => v -> Datum
mdatum :: IsDatum v => v -> Maybe Datum
maybeDatumToken :: Token -> Maybe Token
isDatumToken :: Token -> Bool
udatum :: Natural -> Datum
sdatum :: Integer -> Datum
bdatum :: ByteString -> Datum
newtype Name
Name :: Datum -> Name
class (Show d) => IsName d
name :: IsName d => d -> Name
mname :: IsName d => d -> Maybe Name
data NamedValue
NamedValue :: Name -> Value -> NamedValue
(.:) :: (IsName n, IsValue v) => n -> v -> NamedValue
infixr 5 .:
newtype List
List :: [Value] -> List
data Value
D :: Datum -> Value
N :: NamedValue -> Value
L :: List -> Value
class IsValue a
value :: IsValue a => a -> Value
mvalue :: IsValue a => a -> Maybe Value
instance GHC.Classes.Eq System.SED.Common.Value.NamedValue
instance GHC.Show.Show System.SED.Common.Value.NamedValue
instance GHC.Classes.Eq System.SED.Common.Value.List
instance GHC.Show.Show System.SED.Common.Value.List
instance GHC.Classes.Eq System.SED.Common.Value.Value
instance GHC.Show.Show System.SED.Common.Value.Value
instance GHC.Classes.Eq System.SED.Common.Value.Name
instance GHC.Show.Show System.SED.Common.Value.Name
instance GHC.Classes.Eq System.SED.Common.Value.Datum
instance GHC.Show.Show System.SED.Common.Value.Datum
instance System.SED.Common.Value.IsValue System.SED.Common.Value.Value
instance System.SED.Common.Value.IsValue System.SED.Common.Value.Datum
instance System.SED.Common.Value.IsValue System.SED.Common.Value.NamedValue
instance System.SED.Common.Value.IsValue System.SED.Common.Value.List
instance System.SED.Common.Value.IsValue System.SED.Common.Token.Token
instance System.SED.Common.Value.IsValue GHC.Natural.Natural
instance System.SED.Common.Value.IsValue GHC.Integer.Type.Integer
instance System.SED.Common.Value.IsValue Data.ByteString.Internal.ByteString
instance System.SED.Common.Value.IsValue GHC.Base.String
instance System.SED.Common.Token.IsToken System.SED.Common.Value.Value
instance System.SED.Common.Value.IsName System.SED.Common.Value.NamedValue
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Value.NamedValue
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Value.List
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Value.Value
instance Test.QuickCheck.Arbitrary.Arbitrary System.SED.Common.Value.NamedValue
instance Test.QuickCheck.Arbitrary.Arbitrary System.SED.Common.Value.List
instance Test.QuickCheck.Arbitrary.Arbitrary System.SED.Common.Value.Value
instance System.SED.Common.Value.IsName System.SED.Common.Value.Name
instance System.SED.Common.Value.IsName System.SED.Common.Value.Datum
instance System.SED.Common.Value.IsName System.SED.Common.Token.Token
instance System.SED.Common.Value.IsName GHC.Natural.Natural
instance System.SED.Common.Value.IsName GHC.Integer.Type.Integer
instance System.SED.Common.Value.IsName Data.ByteString.Internal.ByteString
instance System.SED.Common.Value.IsName GHC.Base.String
instance System.SED.Common.Token.IsToken System.SED.Common.Value.Name
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Value.Name
instance System.SED.Common.Value.IsDatum System.SED.Common.Value.Name
instance Test.QuickCheck.Arbitrary.Arbitrary System.SED.Common.Value.Name
instance System.SED.Common.Value.IsDatum System.SED.Common.Value.Datum
instance System.SED.Common.Value.IsDatum System.SED.Common.Token.Token
instance System.SED.Common.Token.IsToken System.SED.Common.Value.Datum
instance System.SED.Common.Value.IsDatum GHC.Natural.Natural
instance System.SED.Common.Value.IsDatum GHC.Integer.Type.Integer
instance System.SED.Common.Value.IsDatum Data.ByteString.Internal.ByteString
instance System.SED.Common.Value.IsDatum GHC.Base.String
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Value.Datum
instance Test.QuickCheck.Arbitrary.Arbitrary System.SED.Common.Value.Datum


-- | Datatypes for Tokens.
module System.SED.Common.Call
data MethodHeader
MethodHeader :: UID -> UID -> MethodHeader
[_invokingID] :: MethodHeader -> UID
[_methodID] :: MethodHeader -> UID
data Parameters
Parameters :: [Value] -> [NamedValue] -> Parameters
[_required] :: Parameters -> [Value]
[_optional] :: Parameters -> [NamedValue]
data MethodCall
MethodCall :: MethodHeader -> Parameters -> Natural -> MethodCall
[_header] :: MethodCall -> MethodHeader
[_parameters] :: MethodCall -> Parameters
[_statusCode] :: MethodCall -> Natural
d :: Natural -> Value
instance GHC.Classes.Eq System.SED.Common.Call.MethodCall
instance GHC.Show.Show System.SED.Common.Call.MethodCall
instance GHC.Classes.Eq System.SED.Common.Call.Parameters
instance GHC.Show.Show System.SED.Common.Call.Parameters
instance GHC.Classes.Eq System.SED.Common.Call.MethodHeader
instance GHC.Show.Show System.SED.Common.Call.MethodHeader
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Call.MethodCall
instance Test.QuickCheck.Arbitrary.Arbitrary System.SED.Common.Call.MethodCall
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Call.Parameters
instance Test.QuickCheck.Arbitrary.Arbitrary System.SED.Common.Call.Parameters
instance System.SED.Common.StreamItem.StreamItem System.SED.Common.Call.MethodHeader
instance Test.QuickCheck.Arbitrary.Arbitrary System.SED.Common.Call.MethodHeader


-- | Datatypes for <tt>hsed</tt>.
module System.SED.Common.Types

module System.SED.Common.Import

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | The value of <tt>seq a b</tt> is bottom if <tt>a</tt> is bottom, and
--   otherwise equal to <tt>b</tt>. In other words, it evaluates the first
--   argument <tt>a</tt> to weak head normal form (WHNF). <tt>seq</tt> is
--   usually introduced to improve performance by avoiding unneeded
--   laziness.
--   
--   A note on evaluation order: the expression <tt>seq a b</tt> does
--   <i>not</i> guarantee that <tt>a</tt> will be evaluated before
--   <tt>b</tt>. The only guarantee given by <tt>seq</tt> is that the both
--   <tt>a</tt> and <tt>b</tt> will be evaluated before <tt>seq</tt>
--   returns a value. In particular, this means that <tt>b</tt> may be
--   evaluated before <tt>a</tt>. If you need to guarantee a specific order
--   of evaluation, you must use the function <tt>pseq</tt> from the
--   "parallel" package.
seq :: a -> b -> b
infixr 0 `seq`

-- | <i>O(n)</i>. <a>filter</a>, applied to a predicate and a list, returns
--   the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; filter odd [1, 2, 3]
--   [1,3]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | <i>O(min(m,n))</i>. <a>zip</a> takes two lists and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   zip [1, 2] ['a', 'b'] = [(1, 'a'), (2, 'b')]
--   </pre>
--   
--   If one input list is short, excess elements of the longer list are
--   discarded:
--   
--   <pre>
--   zip [1] ['a', 'b'] = [(1, 'a')]
--   zip [1, 2] ['a'] = [(1, 'a')]
--   </pre>
--   
--   <a>zip</a> is right-lazy:
--   
--   <pre>
--   zip [] _|_ = []
--   zip _|_ [] = _|_
--   </pre>
--   
--   <a>zip</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zip :: [a] -> [b] -> [(a, b)]

-- | Extract the first component of a pair.
fst :: (a, b) -> a

-- | Extract the second component of a pair.
snd :: (a, b) -> b

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <a>AssertionFailed</a> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a

-- | <i>O(n)</i>. <a>map</a> <tt>f xs</tt> is the list obtained by applying
--   <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (+1) [1, 2, 3]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>(<a>$</a>)</tt> is levity-polymorphic in its result
--   type, so that <tt>foo <a>$</a> True</tt> where <tt>foo :: Bool -&gt;
--   Int#</tt> is well-typed.
($) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $

-- | general coercion from integral types
fromIntegral :: (Integral a, Num b) => a -> b

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a

-- | Convert to an <a>Int</a>. It is implementation-dependent what
--   <a>fromEnum</a> returns when applied to a value that is too large to
--   fit in an <a>Int</a>.
fromEnum :: Enum a => a -> Int

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=

-- | Trigonometric and hyperbolic functions and related functions.
--   
--   The Haskell Report defines no laws for <a>Floating</a>. However,
--   <tt>(<a>+</a>)</tt>, <tt>(<a>*</a>)</tt> and <a>exp</a> are
--   customarily expected to define an exponential field and have the
--   following properties:
--   
--   <ul>
--   <li><tt>exp (a + b)</tt> = <tt>exp a * exp b</tt></li>
--   <li><tt>exp (fromInteger 0)</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
class Fractional a => Floating a
pi :: Floating a => a
exp :: Floating a => a -> a
log :: Floating a => a -> a
sqrt :: Floating a => a -> a
(**) :: Floating a => a -> a -> a
logBase :: Floating a => a -> a -> a
sin :: Floating a => a -> a
cos :: Floating a => a -> a
tan :: Floating a => a -> a
asin :: Floating a => a -> a
acos :: Floating a => a -> a
atan :: Floating a => a -> a
sinh :: Floating a => a -> a
cosh :: Floating a => a -> a
tanh :: Floating a => a -> a
asinh :: Floating a => a -> a
acosh :: Floating a => a -> a
atanh :: Floating a => a -> a
infixr 8 **

-- | Fractional numbers, supporting real division.
--   
--   The Haskell Report defines no laws for <a>Fractional</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a division ring and have the following properties:
--   
--   <ul>
--   <li><i><b><a>recip</a> gives the multiplicative inverse</b></i> <tt>x
--   * recip x</tt> = <tt>recip x * x</tt> = <tt>fromInteger 1</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   <a>Fractional</a> implement a field. However, all instances in
--   <tt>base</tt> do.
class Num a => Fractional a

-- | Fractional division.
(/) :: Fractional a => a -> a -> a

-- | Reciprocal fraction.
recip :: Fractional a => a -> a

-- | Conversion from a <a>Rational</a> (that is <tt><a>Ratio</a>
--   <a>Integer</a></tt>). A floating literal stands for an application of
--   <a>fromRational</a> to a value of type <a>Rational</a>, so such
--   literals have type <tt>(<a>Fractional</a> a) =&gt; a</tt>.
fromRational :: Fractional a => Rational -> a
infixl 7 /

-- | Integral numbers, supporting integer division.
--   
--   The Haskell Report defines no laws for <a>Integral</a>. However,
--   <a>Integral</a> instances are customarily expected to define a
--   Euclidean domain and have the following properties for the
--   <a>div</a>/<a>mod</a> and <a>quot</a>/<a>rem</a> pairs, given suitable
--   Euclidean functions <tt>f</tt> and <tt>g</tt>:
--   
--   <ul>
--   <li><tt>x</tt> = <tt>y * quot x y + rem x y</tt> with <tt>rem x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>g (rem x y)</tt> &lt; <tt>g
--   y</tt></li>
--   <li><tt>x</tt> = <tt>y * div x y + mod x y</tt> with <tt>mod x y</tt>
--   = <tt>fromInteger 0</tt> or <tt>f (mod x y)</tt> &lt; <tt>f
--   y</tt></li>
--   </ul>
--   
--   An example of a suitable Euclidean function, for <a>Integer</a>'s
--   instance, is <a>abs</a>.
class (Real a, Enum a) => Integral a

-- | integer division truncated toward zero
quot :: Integral a => a -> a -> a

-- | integer remainder, satisfying
--   
--   <pre>
--   (x `quot` y)*y + (x `rem` y) == x
--   </pre>
rem :: Integral a => a -> a -> a

-- | integer division truncated toward negative infinity
div :: Integral a => a -> a -> a

-- | integer modulus, satisfying
--   
--   <pre>
--   (x `div` y)*y + (x `mod` y) == x
--   </pre>
mod :: Integral a => a -> a -> a

-- | simultaneous <a>quot</a> and <a>rem</a>
quotRem :: Integral a => a -> a -> (a, a)

-- | simultaneous <a>div</a> and <a>mod</a>
divMod :: Integral a => a -> a -> (a, a)

-- | conversion to <a>Integer</a>
toInteger :: Integral a => a -> Integer
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
(>>=) :: Monad m => m a -> (a -> m b) -> m b

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a
infixl 1 >>=
infixl 1 >>

-- | The <a>Data</a> class comprehends a fundamental primitive
--   <a>gfoldl</a> for folding over constructor applications, say terms.
--   This primitive can be instantiated in several ways to map over the
--   immediate subterms of a term; see the <tt>gmap</tt> combinators later
--   in this class. Indeed, a generic programmer does not necessarily need
--   to use the ingenious gfoldl primitive but rather the intuitive
--   <tt>gmap</tt> combinators. The <a>gfoldl</a> primitive is completed by
--   means to query top-level constructors, to turn constructor
--   representations into proper terms, and to list all possible datatype
--   constructors. This completion allows us to serve generic programming
--   scenarios like read, show, equality, term generation.
--   
--   The combinators <a>gmapT</a>, <a>gmapQ</a>, <a>gmapM</a>, etc are all
--   provided with default definitions in terms of <a>gfoldl</a>, leaving
--   open the opportunity to provide datatype-specific definitions. (The
--   inclusion of the <tt>gmap</tt> combinators as members of class
--   <a>Data</a> allows the programmer or the compiler to derive
--   specialised, and maybe more efficient code per datatype. <i>Note</i>:
--   <a>gfoldl</a> is more higher-order than the <tt>gmap</tt> combinators.
--   This is subject to ongoing benchmarking experiments. It might turn out
--   that the <tt>gmap</tt> combinators will be moved out of the class
--   <a>Data</a>.)
--   
--   Conceptually, the definition of the <tt>gmap</tt> combinators in terms
--   of the primitive <a>gfoldl</a> requires the identification of the
--   <a>gfoldl</a> function arguments. Technically, we also need to
--   identify the type constructor <tt>c</tt> for the construction of the
--   result type from the folded term type.
--   
--   In the definition of <tt>gmapQ</tt><i>x</i> combinators, we use
--   phantom type constructors for the <tt>c</tt> in the type of
--   <a>gfoldl</a> because the result type of a query does not involve the
--   (polymorphic) type of the term argument. In the definition of
--   <a>gmapQl</a> we simply use the plain constant type constructor
--   because <a>gfoldl</a> is left-associative anyway and so it is readily
--   suited to fold a left-associative binary operation over the immediate
--   subterms. In the definition of gmapQr, extra effort is needed. We use
--   a higher-order accumulation trick to mediate between left-associative
--   constructor application vs. right-associative binary operation (e.g.,
--   <tt>(:)</tt>). When the query is meant to compute a value of type
--   <tt>r</tt>, then the result type withing generic folding is <tt>r
--   -&gt; r</tt>. So the result of folding is a function to which we
--   finally pass the right unit.
--   
--   With the <tt>-XDeriveDataTypeable</tt> option, GHC can generate
--   instances of the <a>Data</a> class automatically. For example, given
--   the declaration
--   
--   <pre>
--   data T a b = C1 a b | C2 deriving (Typeable, Data)
--   </pre>
--   
--   GHC will generate an instance that is equivalent to
--   
--   <pre>
--   instance (Data a, Data b) =&gt; Data (T a b) where
--       gfoldl k z (C1 a b) = z C1 `k` a `k` b
--       gfoldl k z C2       = z C2
--   
--       gunfold k z c = case constrIndex c of
--                           1 -&gt; k (k (z C1))
--                           2 -&gt; z C2
--   
--       toConstr (C1 _ _) = con_C1
--       toConstr C2       = con_C2
--   
--       dataTypeOf _ = ty_T
--   
--   con_C1 = mkConstr ty_T "C1" [] Prefix
--   con_C2 = mkConstr ty_T "C2" [] Prefix
--   ty_T   = mkDataType "Module.T" [con_C1, con_C2]
--   </pre>
--   
--   This is suitable for datatypes that are exported transparently.
class Typeable a => Data a

-- | Left-associative fold operation for constructor applications.
--   
--   The type of <a>gfoldl</a> is a headache, but operationally it is a
--   simple generalisation of a list fold.
--   
--   The default definition for <a>gfoldl</a> is <tt><a>const</a>
--   <a>id</a></tt>, which is suitable for abstract datatypes with no
--   substructures.
gfoldl :: Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. () => g -> c g) -> a -> c a

-- | Unfolding constructor applications
gunfold :: Data a => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. () => r -> c r) -> Constr -> c a

-- | Obtaining the constructor from a given datum. For proper terms, this
--   is meant to be the top-level constructor. Primitive datatypes are here
--   viewed as potentially infinite sets of values (i.e., constructors).
toConstr :: Data a => a -> Constr

-- | The outer type constructor of the type
dataTypeOf :: Data a => a -> DataType

-- | Mediate types and unary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, ...) =&gt; Data (T a)
--   </pre>
--   
--   <a>dataCast1</a> should be defined as <a>gcast1</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast1 :: (Data a, Typeable t) => (forall d. Data d => c (t d)) -> Maybe (c a)

-- | Mediate types and binary type constructors.
--   
--   In <a>Data</a> instances of the form
--   
--   <pre>
--   instance (Data a, Data b, ...) =&gt; Data (T a b)
--   </pre>
--   
--   <a>dataCast2</a> should be defined as <a>gcast2</a>.
--   
--   The default definition is <tt><a>const</a> <a>Nothing</a></tt>, which
--   is appropriate for instances of other forms.
dataCast2 :: (Data a, Typeable t) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)

-- | A generic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to an identity datatype constructor, using
--   the isomorphism pair as injection and projection.
gmapT :: Data a => (forall b. Data b => b -> b) -> a -> a

-- | A generic query with a left-associative binary operator
gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query with a right-associative binary operator
gmapQr :: forall r r'. Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r

-- | A generic query that processes the immediate subterms and returns a
--   list of results. The list is given in the same order as originally
--   specified in the declaration of the data constructors.
gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]

-- | A generic query that processes one child by index (zero-based)
gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u

-- | A generic monadic transformation that maps over the immediate subterms
--   
--   The default definition instantiates the type constructor <tt>c</tt> in
--   the type of <a>gfoldl</a> to the monad datatype constructor, defining
--   injection and projection using <a>return</a> and <a>&gt;&gt;=</a>.
gmapM :: (Data a, Monad m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of at least one immediate subterm does not fail
gmapMp :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | Transformation of one immediate subterm with success
gmapMo :: (Data a, MonadPlus m) => (forall d. Data d => d -> m d) -> a -> m a

-- | A type <tt>f</tt> is a Functor if it provides a function <tt>fmap</tt>
--   which, given any types <tt>a</tt> and <tt>b</tt> lets you apply any
--   function from <tt>(a -&gt; b)</tt> to turn an <tt>f a</tt> into an
--   <tt>f b</tt>, preserving the structure of <tt>f</tt>. Furthermore
--   <tt>f</tt> needs to adhere to the following:
--   
--   <ul>
--   <li><i>Identity</i> <tt><a>fmap</a> <a>id</a> == <a>id</a></tt></li>
--   <li><i>Composition</i> <tt><a>fmap</a> (f . g) == <a>fmap</a> f .
--   <a>fmap</a> g</tt></li>
--   </ul>
--   
--   Note, that the second law follows from the free theorem of the type
--   <a>fmap</a> and the first law, so you need only check that the former
--   condition holds.
class Functor (f :: Type -> Type)
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Basic numeric class.
--   
--   The Haskell Report defines no laws for <a>Num</a>. However,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>*</a>)</tt> are customarily expected
--   to define a ring and have the following properties:
--   
--   <ul>
--   <li><i><b>Associativity of <tt>(<a>+</a>)</tt></b></i> <tt>(x + y) +
--   z</tt> = <tt>x + (y + z)</tt></li>
--   <li><i><b>Commutativity of <tt>(<a>+</a>)</tt></b></i> <tt>x + y</tt>
--   = <tt>y + x</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 0</tt> is the additive
--   identity</b></i> <tt>x + fromInteger 0</tt> = <tt>x</tt></li>
--   <li><i><b><a>negate</a> gives the additive inverse</b></i> <tt>x +
--   negate x</tt> = <tt>fromInteger 0</tt></li>
--   <li><i><b>Associativity of <tt>(<a>*</a>)</tt></b></i> <tt>(x * y) *
--   z</tt> = <tt>x * (y * z)</tt></li>
--   <li><i><b><tt><a>fromInteger</a> 1</tt> is the multiplicative
--   identity</b></i> <tt>x * fromInteger 1</tt> = <tt>x</tt> and
--   <tt>fromInteger 1 * x</tt> = <tt>x</tt></li>
--   <li><i><b>Distributivity of <tt>(<a>*</a>)</tt> with respect to
--   <tt>(<a>+</a>)</tt></b></i> <tt>a * (b + c)</tt> = <tt>(a * b) + (a *
--   c)</tt> and <tt>(b + c) * a</tt> = <tt>(b * a) + (c * a)</tt></li>
--   </ul>
--   
--   Note that it <i>isn't</i> customarily expected that a type instance of
--   both <a>Num</a> and <a>Ord</a> implement an ordered ring. Indeed, in
--   <tt>base</tt> only <a>Integer</a> and <a>Rational</a> do.
class Num a
(+) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a

-- | Unary negation.
negate :: Num a => a -> a

-- | Absolute value.
abs :: Num a => a -> a

-- | Sign of a number. The functions <a>abs</a> and <a>signum</a> should
--   satisfy the law:
--   
--   <pre>
--   abs x * signum x == x
--   </pre>
--   
--   For real numbers, the <a>signum</a> is either <tt>-1</tt> (negative),
--   <tt>0</tt> (zero) or <tt>1</tt> (positive).
signum :: Num a => a -> a

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
infixl 6 +
infixl 7 *
infixl 6 -

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 >
infix 4 <=
infix 4 <

-- | Parsing of <a>String</a>s, producing values.
--   
--   Derived instances of <a>Read</a> make the following assumptions, which
--   derived instances of <a>Show</a> obey:
--   
--   <ul>
--   <li>If the constructor is defined to be an infix operator, then the
--   derived <a>Read</a> instance will parse only infix applications of the
--   constructor (not the prefix form).</li>
--   <li>Associativity is not used to reduce the occurrence of parentheses,
--   although precedence may be.</li>
--   <li>If the constructor is defined using record syntax, the derived
--   <a>Read</a> will parse only the record-syntax form, and furthermore,
--   the fields must be given in the same order as the original
--   declaration.</li>
--   <li>The derived <a>Read</a> instance allows arbitrary Haskell
--   whitespace between tokens of the input string. Extra parentheses are
--   also allowed.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Read</a> in Haskell 2010 is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readsPrec d r =  readParen (d &gt; app_prec)
--                            (\r -&gt; [(Leaf m,t) |
--                                    ("Leaf",s) &lt;- lex r,
--                                    (m,t) &lt;- readsPrec (app_prec+1) s]) r
--   
--                         ++ readParen (d &gt; up_prec)
--                            (\r -&gt; [(u:^:v,w) |
--                                    (u,s) &lt;- readsPrec (up_prec+1) r,
--                                    (":^:",t) &lt;- lex s,
--                                    (v,w) &lt;- readsPrec (up_prec+1) t]) r
--   
--             where app_prec = 10
--                   up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is unused.
--   
--   The derived instance in GHC is equivalent to
--   
--   <pre>
--   instance (Read a) =&gt; Read (Tree a) where
--   
--           readPrec = parens $ (prec app_prec $ do
--                                    Ident "Leaf" &lt;- lexP
--                                    m &lt;- step readPrec
--                                    return (Leaf m))
--   
--                        +++ (prec up_prec $ do
--                                    u &lt;- step readPrec
--                                    Symbol ":^:" &lt;- lexP
--                                    v &lt;- step readPrec
--                                    return (u :^: v))
--   
--             where app_prec = 10
--                   up_prec = 5
--   
--           readListPrec = readListPrecDefault
--   </pre>
--   
--   Why do both <a>readsPrec</a> and <a>readPrec</a> exist, and why does
--   GHC opt to implement <a>readPrec</a> in derived <a>Read</a> instances
--   instead of <a>readsPrec</a>? The reason is that <a>readsPrec</a> is
--   based on the <a>ReadS</a> type, and although <a>ReadS</a> is mentioned
--   in the Haskell 2010 Report, it is not a very efficient parser data
--   structure.
--   
--   <a>readPrec</a>, on the other hand, is based on a much more efficient
--   <a>ReadPrec</a> datatype (a.k.a "new-style parsers"), but its
--   definition relies on the use of the <tt>RankNTypes</tt> language
--   extension. Therefore, <a>readPrec</a> (and its cousin,
--   <a>readListPrec</a>) are marked as GHC-only. Nevertheless, it is
--   recommended to use <a>readPrec</a> instead of <a>readsPrec</a>
--   whenever possible for the efficiency improvements it brings.
--   
--   As mentioned above, derived <a>Read</a> instances in GHC will
--   implement <a>readPrec</a> instead of <a>readsPrec</a>. The default
--   implementations of <a>readsPrec</a> (and its cousin, <a>readList</a>)
--   will simply use <a>readPrec</a> under the hood. If you are writing a
--   <a>Read</a> instance by hand, it is recommended to write it like so:
--   
--   <pre>
--   instance <a>Read</a> T where
--     <a>readPrec</a>     = ...
--     <a>readListPrec</a> = <a>readListPrecDefault</a>
--   </pre>
class Read a
class (Num a, Ord a) => Real a

-- | the rational equivalent of its real argument with full precision
toRational :: Real a => a -> Rational

-- | Efficient, machine-independent access to the components of a
--   floating-point number.
class (RealFrac a, Floating a) => RealFloat a

-- | a constant function, returning the radix of the representation (often
--   <tt>2</tt>)
floatRadix :: RealFloat a => a -> Integer

-- | a constant function, returning the number of digits of
--   <a>floatRadix</a> in the significand
floatDigits :: RealFloat a => a -> Int

-- | a constant function, returning the lowest and highest values the
--   exponent may assume
floatRange :: RealFloat a => a -> (Int, Int)

-- | The function <a>decodeFloat</a> applied to a real floating-point
--   number returns the significand expressed as an <a>Integer</a> and an
--   appropriately scaled exponent (an <a>Int</a>). If
--   <tt><a>decodeFloat</a> x</tt> yields <tt>(m,n)</tt>, then <tt>x</tt>
--   is equal in value to <tt>m*b^^n</tt>, where <tt>b</tt> is the
--   floating-point radix, and furthermore, either <tt>m</tt> and
--   <tt>n</tt> are both zero or else <tt>b^(d-1) &lt;= <a>abs</a> m &lt;
--   b^d</tt>, where <tt>d</tt> is the value of <tt><a>floatDigits</a>
--   x</tt>. In particular, <tt><a>decodeFloat</a> 0 = (0,0)</tt>. If the
--   type contains a negative zero, also <tt><a>decodeFloat</a> (-0.0) =
--   (0,0)</tt>. <i>The result of</i> <tt><a>decodeFloat</a> x</tt> <i>is
--   unspecified if either of</i> <tt><a>isNaN</a> x</tt> <i>or</i>
--   <tt><a>isInfinite</a> x</tt> <i>is</i> <a>True</a>.
decodeFloat :: RealFloat a => a -> (Integer, Int)

-- | <a>encodeFloat</a> performs the inverse of <a>decodeFloat</a> in the
--   sense that for finite <tt>x</tt> with the exception of <tt>-0.0</tt>,
--   <tt><a>uncurry</a> <a>encodeFloat</a> (<a>decodeFloat</a> x) = x</tt>.
--   <tt><a>encodeFloat</a> m n</tt> is one of the two closest
--   representable floating-point numbers to <tt>m*b^^n</tt> (or
--   <tt>±Infinity</tt> if overflow occurs); usually the closer, but if
--   <tt>m</tt> contains too many bits, the result may be rounded in the
--   wrong direction.
encodeFloat :: RealFloat a => Integer -> Int -> a

-- | <a>exponent</a> corresponds to the second component of
--   <a>decodeFloat</a>. <tt><a>exponent</a> 0 = 0</tt> and for finite
--   nonzero <tt>x</tt>, <tt><a>exponent</a> x = snd (<a>decodeFloat</a> x)
--   + <a>floatDigits</a> x</tt>. If <tt>x</tt> is a finite floating-point
--   number, it is equal in value to <tt><a>significand</a> x * b ^^
--   <a>exponent</a> x</tt>, where <tt>b</tt> is the floating-point radix.
--   The behaviour is unspecified on infinite or <tt>NaN</tt> values.
exponent :: RealFloat a => a -> Int

-- | The first component of <a>decodeFloat</a>, scaled to lie in the open
--   interval (<tt>-1</tt>,<tt>1</tt>), either <tt>0.0</tt> or of absolute
--   value <tt>&gt;= 1/b</tt>, where <tt>b</tt> is the floating-point
--   radix. The behaviour is unspecified on infinite or <tt>NaN</tt>
--   values.
significand :: RealFloat a => a -> a

-- | multiplies a floating-point number by an integer power of the radix
scaleFloat :: RealFloat a => Int -> a -> a

-- | <a>True</a> if the argument is an IEEE "not-a-number" (NaN) value
isNaN :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE infinity or negative infinity
isInfinite :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is too small to be represented in
--   normalized format
isDenormalized :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE negative zero
isNegativeZero :: RealFloat a => a -> Bool

-- | <a>True</a> if the argument is an IEEE floating point number
isIEEE :: RealFloat a => a -> Bool

-- | a version of arctangent taking two real floating-point arguments. For
--   real floating <tt>x</tt> and <tt>y</tt>, <tt><a>atan2</a> y x</tt>
--   computes the angle (from the positive x-axis) of the vector from the
--   origin to the point <tt>(x,y)</tt>. <tt><a>atan2</a> y x</tt> returns
--   a value in the range [<tt>-pi</tt>, <tt>pi</tt>]. It follows the
--   Common Lisp semantics for the origin when signed zeroes are supported.
--   <tt><a>atan2</a> y 1</tt>, with <tt>y</tt> in a type that is
--   <a>RealFloat</a>, should return the same value as <tt><a>atan</a>
--   y</tt>. A default definition of <a>atan2</a> is provided, but
--   implementors can provide a more accurate implementation.
atan2 :: RealFloat a => a -> a -> a

-- | Extracting components of fractions.
class (Real a, Fractional a) => RealFrac a

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <a>ceiling</a>, <a>floor</a>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: (RealFrac a, Integral b) => a -> (b, a)

-- | <tt><a>truncate</a> x</tt> returns the integer nearest <tt>x</tt>
--   between zero and <tt>x</tt>
truncate :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>round</a> x</tt> returns the nearest integer to <tt>x</tt>; the
--   even integer if <tt>x</tt> is equidistant between two integers
round :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>ceiling</a> x</tt> returns the least integer not less than
--   <tt>x</tt>
ceiling :: (RealFrac a, Integral b) => a -> b

-- | <tt><a>floor</a> x</tt> returns the greatest integer not greater than
--   <tt>x</tt>
floor :: (RealFrac a, Integral b) => a -> b

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)

-- | When a value is bound in <tt>do</tt>-notation, the pattern on the left
--   hand side of <tt>&lt;-</tt> might not match. In this case, this class
--   provides a function to recover.
--   
--   A <a>Monad</a> without a <a>MonadFail</a> instance may only be used in
--   conjunction with pattern that always match, such as newtypes, tuples,
--   data types with only a single data constructor, and irrefutable
--   patterns (<tt>~pat</tt>).
--   
--   Instances of <a>MonadFail</a> should satisfy the following law:
--   <tt>fail s</tt> should be a left zero for <a>&gt;&gt;=</a>,
--   
--   <pre>
--   fail s &gt;&gt;= f  =  fail s
--   </pre>
--   
--   If your <a>Monad</a> is also <a>MonadPlus</a>, a popular definition is
--   
--   <pre>
--   fail _ = mzero
--   </pre>
class Monad m => MonadFail (m :: Type -> Type)
fail :: MonadFail m => String -> m a

-- | Class for string-like datastructures; used by the overloaded string
--   extension (-XOverloadedStrings in GHC).
class IsString a
fromString :: IsString a => String -> a

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results (<a>&lt;*&gt;</a>
--   and <a>liftA2</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of
--   <a>pure</a> and of either <a>&lt;*&gt;</a> or <a>liftA2</a>. If it
--   defines both, then they must behave the same as their default
--   definitions:
--   
--   <pre>
--   (<a>&lt;*&gt;</a>) = <a>liftA2</a> <a>id</a>
--   </pre>
--   
--   <pre>
--   <a>liftA2</a> f x y = f <a>&lt;$&gt;</a> x <a>&lt;*&gt;</a> y
--   </pre>
--   
--   Further, any definition must satisfy the following:
--   
--   <ul>
--   <li><i>Identity</i> <pre><a>pure</a> <a>id</a> <a>&lt;*&gt;</a> v =
--   v</pre></li>
--   <li><i>Composition</i> <pre><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</pre></li>
--   <li><i>Homomorphism</i> <pre><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</pre></li>
--   <li><i>Interchange</i> <pre>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</pre></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <ul>
--   <li><pre>u <a>*&gt;</a> v = (<a>id</a> <a>&lt;$</a> u)
--   <a>&lt;*&gt;</a> v</pre></li>
--   <li><pre>u <a>&lt;*</a> v = <a>liftA2</a> <a>const</a> u v</pre></li>
--   </ul>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <ul>
--   <li><pre><a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x</pre></li>
--   </ul>
--   
--   It may be useful to note that supposing
--   
--   <pre>
--   forall x y. p (q x y) = f x . g y
--   </pre>
--   
--   it follows from the above that
--   
--   <pre>
--   <a>liftA2</a> p (<a>liftA2</a> q u v) = <a>liftA2</a> f u . <a>liftA2</a> g v
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>(<a>&lt;*&gt;</a>) = <a>ap</a></pre></li>
--   <li><pre>(<a>*&gt;</a>) = (<a>&gt;&gt;</a>)</pre></li>
--   </ul>
--   
--   (which implies that <a>pure</a> and <a>&lt;*&gt;</a> satisfy the
--   applicative functor laws).
class Functor f => Applicative (f :: Type -> Type)

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Sequential application.
--   
--   A few functors support an implementation of <a>&lt;*&gt;</a> that is
--   more efficient than the default one.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | Lift a binary function to actions.
--   
--   Some functors support an implementation of <a>liftA2</a> that is more
--   efficient than the default one. In particular, if <a>fmap</a> is an
--   expensive operation, it is likely better to use <a>liftA2</a> than to
--   <a>fmap</a> over the structure and then use <a>&lt;*&gt;</a>.
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Sequence actions, discarding the value of the first argument.
(*>) :: Applicative f => f a -> f b -> f b

-- | Sequence actions, discarding the value of the second argument.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*>
infixl 4 *>
infixl 4 <*

-- | Data structures that can be folded.
--   
--   For example, given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Foldable Tree where
--      foldMap f Empty = mempty
--      foldMap f (Leaf x) = f x
--      foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
--   </pre>
--   
--   This is suitable even for abstract types, as the monoid is assumed to
--   satisfy the monoid laws. Alternatively, one could define
--   <tt>foldr</tt>:
--   
--   <pre>
--   instance Foldable Tree where
--      foldr f z Empty = z
--      foldr f z (Leaf x) = f x z
--      foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--   </pre>
--   
--   <tt>Foldable</tt> instances are expected to satisfy the following
--   laws:
--   
--   <pre>
--   foldr f z t = appEndo (foldMap (Endo . f) t ) z
--   </pre>
--   
--   <pre>
--   foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
--   </pre>
--   
--   <pre>
--   fold = foldMap id
--   </pre>
--   
--   <pre>
--   length = getSum . foldMap (Sum . const  1)
--   </pre>
--   
--   <tt>sum</tt>, <tt>product</tt>, <tt>maximum</tt>, and <tt>minimum</tt>
--   should all be essentially equivalent to <tt>foldMap</tt> forms, such
--   as
--   
--   <pre>
--   sum = getSum . foldMap Sum
--   </pre>
--   
--   but may be less defined.
--   
--   If the type is also a <a>Functor</a> instance, it should satisfy
--   
--   <pre>
--   foldMap f = fold . fmap f
--   </pre>
--   
--   which implies that
--   
--   <pre>
--   foldMap f . fmap g = foldMap (f . g)
--   </pre>
class Foldable (t :: Type -> Type)

-- | Combine the elements of a structure using a monoid.
fold :: (Foldable t, Monoid m) => t m -> m

-- | Map each element of the structure to a monoid, and combine the
--   results.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr</a>, when applied to a binary operator,
--   a starting value (typically the right-identity of the operator), and a
--   list, reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr f z = <a>foldr</a> f z . <a>toList</a>
--   </pre>
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <a>length</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | List of elements of a structure, from left to right.
toList :: Foldable t => t a -> [a]

-- | Test whether the structure is empty. The default implementation is
--   optimized for structures that are similar to cons-lists, because there
--   is no general way to do better.
null :: Foldable t => t a -> Bool

-- | Returns the size/length of a finite structure as an <a>Int</a>. The
--   default implementation is optimized for structures that are similar to
--   cons-lists, because there is no general way to do better.
length :: Foldable t => t a -> Int

-- | Does the element occur in the structure?
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | The <a>sum</a> function computes the sum of the numbers of a
--   structure.
sum :: (Foldable t, Num a) => t a -> a

-- | The <a>product</a> function computes the product of the numbers of a
--   structure.
product :: (Foldable t, Num a) => t a -> a
infix 4 `elem`

-- | Functors representing data structures that can be traversed from left
--   to right.
--   
--   A definition of <a>traverse</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>traverse</a> f = <a>traverse</a> (t .
--   f)</tt> for every applicative transformation <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>traverse</a> <a>Identity</a> =
--   <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>traverse</a> (<a>Compose</a> .
--   <a>fmap</a> g . f) = <a>Compose</a> . <a>fmap</a> (<a>traverse</a> g)
--   . <a>traverse</a> f</tt></li>
--   </ul>
--   
--   A definition of <a>sequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i>Naturality</i> <tt>t . <a>sequenceA</a> = <a>sequenceA</a> .
--   <a>fmap</a> t</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i>Identity</i> <tt><a>sequenceA</a> . <a>fmap</a> <a>Identity</a>
--   = <a>Identity</a></tt></li>
--   <li><i>Composition</i> <tt><a>sequenceA</a> . <a>fmap</a>
--   <a>Compose</a> = <a>Compose</a> . <a>fmap</a> <a>sequenceA</a> .
--   <a>sequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <a>Identity</a> and composition functors
--   <a>Compose</a> are from <a>Data.Functor.Identity</a> and
--   <a>Data.Functor.Compose</a>.
--   
--   (The naturality law is implied by parametricity.)
--   
--   Instances are similar to <a>Functor</a>, e.g. given a data type
--   
--   <pre>
--   data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
--   </pre>
--   
--   a suitable instance would be
--   
--   <pre>
--   instance Traversable Tree where
--      traverse f Empty = pure Empty
--      traverse f (Leaf x) = Leaf &lt;$&gt; f x
--      traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r
--   </pre>
--   
--   This is suitable even for abstract types, as the laws for
--   <a>&lt;*&gt;</a> imply a form of associativity.
--   
--   The superclass instances should satisfy the following:
--   
--   <ul>
--   <li>In the <a>Functor</a> instance, <a>fmap</a> should be equivalent
--   to traversal with the identity applicative functor
--   (<a>fmapDefault</a>).</li>
--   <li>In the <a>Foldable</a> instance, <a>foldMap</a> should be
--   equivalent to traversal with a constant applicative functor
--   (<a>foldMapDefault</a>).</li>
--   </ul>
class (Functor t, Foldable t) => Traversable (t :: Type -> Type)

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and collect the results. For a version that
--   ignores the results see <a>traverse_</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Evaluate each action in the structure from left to right, and collect
--   the results. For a version that ignores the results see
--   <a>sequenceA_</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and collect the results. For a version
--   that ignores the results see <a>mapM_</a>.
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)

-- | Evaluate each monadic action in the structure from left to right, and
--   collect the results. For a version that ignores the results see
--   <a>sequence_</a>.
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class Generic a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following:
--   
--   <ul>
--   <li><i>Right identity</i> <tt>x <a>&lt;&gt;</a> <a>mempty</a> =
--   x</tt></li>
--   <li><i>Left identity</i> <tt><a>mempty</a> <a>&lt;&gt;</a> x =
--   x</tt></li>
--   <li><i>Associativity</i> <tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) =
--   (x <a>&lt;&gt;</a> y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a>
--   law)</li>
--   <li><i>Concatenation</i> <tt><a>mconcat</a> = <a>foldr</a>
--   (<a>&lt;&gt;</a>) <a>mempty</a></tt></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = (<a>&lt;&gt;</a>)</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
mconcat :: Monoid a => [a] -> a
data Bool
False :: Bool
True :: Bool

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) code points (i.e.
--   characters, see <a>http://www.unicode.org/</a> for details). This set
--   extends the ISO 8859-1 (Latin-1) character set (the first 256
--   characters), which is itself an extension of the ASCII character set
--   (the first 128 characters). A character literal in Haskell has type
--   <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <a>ord</a> and
--   <a>chr</a>).
data Char

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int

-- | 8-bit signed integer type
data Int8

-- | 16-bit signed integer type
data Int16

-- | 32-bit signed integer type
data Int32

-- | 64-bit signed integer type
data Int64

-- | Invariant: <a>Jn#</a> and <a>Jp#</a> are used iff value doesn't fit in
--   <a>S#</a>
--   
--   Useful properties resulting from the invariants:
--   
--   <ul>
--   <li><pre>abs (<a>S#</a> _) &lt;= abs (<a>Jp#</a> _)</pre></li>
--   <li><pre>abs (<a>S#</a> _) &lt; abs (<a>Jn#</a> _)</pre></li>
--   </ul>
data Integer

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><a>throw</a>
--   (<a>Underflow</a> :: <a>ArithException</a>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | Arbitrary-precision rational numbers, represented as a ratio of two
--   <a>Integer</a> values. A rational number may be constructed using the
--   <a>%</a> operator.
type Rational = Ratio Integer

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <a>&gt;&gt;</a> and <a>&gt;&gt;=</a>
--   operations from the <a>Monad</a> class.
data IO a

-- | A <a>Word</a> is an unsigned integral type, with the same size as
--   <a>Int</a>.
data Word

-- | 8-bit unsigned integer type
data Word8

-- | 16-bit unsigned integer type
data Word16

-- | 32-bit unsigned integer type
data Word32

-- | 64-bit unsigned integer type
data Word64

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:2:1 in interactive:Ghci1
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data CallStack

-- | A <a>String</a> is a list of characters. String constants in Haskell
--   are values of type <a>String</a>.
type String = [Char]

-- | The strict <a>ST</a> monad. The <a>ST</a> monad allows for destructive
--   updates, but is escapable (unlike IO). A computation of type
--   <tt><a>ST</a> s a</tt> returns a value of type <tt>a</tt>, and execute
--   in "thread" <tt>s</tt>. The <tt>s</tt> parameter is either
--   
--   <ul>
--   <li>an uninstantiated type variable (inside invocations of
--   <a>runST</a>), or</li>
--   <li><a>RealWorld</a> (inside invocations of <a>stToIO</a>).</li>
--   </ul>
--   
--   It serves to keep the internal states of different invocations of
--   <a>runST</a> separate from each other and from invocations of
--   <a>stToIO</a>.
--   
--   The <a>&gt;&gt;=</a> and <a>&gt;&gt;</a> operations are strict in the
--   state (though not in values stored in the state). For example,
--   
--   <pre>
--   <a>runST</a> (writeSTRef _|_ v &gt;&gt;= f) = _|_
--   </pre>
data ST s a

-- | Promote a function to a monad.
liftM :: Monad m => (a1 -> r) -> m a1 -> m r

-- | Identity function.
--   
--   <pre>
--   id x = x
--   </pre>
id :: a -> a

-- | Case analysis for the <a>Either</a> type. If the value is
--   <tt><a>Left</a> a</tt>, apply the first function to <tt>a</tt>; if it
--   is <tt><a>Right</a> b</tt>, apply the second function to <tt>b</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   We create two values of type <tt><a>Either</a> <a>String</a>
--   <a>Int</a></tt>, one using the <a>Left</a> constructor and another
--   using the <a>Right</a> constructor. Then we apply "either" the
--   <a>length</a> function (if we have a <a>String</a>) or the "times-two"
--   function (if we have an <a>Int</a>):
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; either length (*2) s
--   3
--   
--   &gt;&gt;&gt; either length (*2) n
--   6
--   </pre>
either :: (a -> c) -> (b -> c) -> Either a b -> c

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r (m :: Type -> Type) | m -> r

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Executes a computation in a modified environment.
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature will hopefully be corrected at a later date.
data ThreadId

-- | A version of <a>waitBoth</a> that can be used inside an STM
--   transaction.
waitBothSTM :: Async a -> Async b -> STM (a, b)

-- | A version of <a>waitEither_</a> that can be used inside an STM
--   transaction.
waitEitherSTM_ :: Async a -> Async b -> STM ()

-- | A version of <a>waitEither</a> that can be used inside an STM
--   transaction.
waitEitherSTM :: Async a -> Async b -> STM (Either a b)

-- | A version of <a>waitEitherCatch</a> that can be used inside an STM
--   transaction.
waitEitherCatchSTM :: Async a -> Async b -> STM (Either (Either SomeException a) (Either SomeException b))

-- | A version of <a>waitAny</a> that can be used inside an STM
--   transaction.
waitAnySTM :: [Async a] -> STM (Async a, a)

-- | A version of <a>waitAnyCatch</a> that can be used inside an STM
--   transaction.
waitAnyCatchSTM :: [Async a] -> STM (Async a, Either SomeException a)

-- | A version of <a>poll</a> that can be used inside an STM transaction.
pollSTM :: Async a -> STM (Maybe (Either SomeException a))

-- | A version of <a>waitCatch</a> that can be used inside an STM
--   transaction.
waitCatchSTM :: Async a -> STM (Either SomeException a)

-- | A version of <a>wait</a> that can be used inside an STM transaction.
waitSTM :: Async a -> STM a

-- | An asynchronous action spawned by <a>async</a> or <a>withAsync</a>.
--   Asynchronous actions are executed in a separate thread, and operations
--   are provided for waiting for asynchronous actions to complete and
--   obtaining their results (see e.g. <a>wait</a>).
data Async a

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString

-- | A space efficient, packed, unboxed Unicode text type.
data Text

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: Type -> Type)

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | Monads that also support choice and failure.
class (Alternative m, Monad m) => MonadPlus (m :: Type -> Type)

-- | The identity of <a>mplus</a>. It should also satisfy the equations
--   
--   <pre>
--   mzero &gt;&gt;= f  =  mzero
--   v &gt;&gt; mzero   =  mzero
--   </pre>
--   
--   The default definition is
--   
--   <pre>
--   mzero = <a>empty</a>
--   </pre>
mzero :: MonadPlus m => m a

-- | An associative operation. The default definition is
--   
--   <pre>
--   mplus = (<a>&lt;|&gt;</a>)
--   </pre>
mplus :: MonadPlus m => m a -> m a -> m a

-- | Since <a>Void</a> values logically don't exist, this witnesses the
--   logical reasoning tool of "ex falso quodlibet".
--   
--   <pre>
--   &gt;&gt;&gt; let x :: Either Void Int; x = Right 5
--   
--   &gt;&gt;&gt; :{
--   case x of
--       Right r -&gt; r
--       Left l  -&gt; absurd l
--   :}
--   5
--   </pre>
absurd :: Void -> a

-- | Uninhabited data type
data Void

-- | <a>Chan</a> is an abstract type representing an unbounded FIFO
--   channel.
data Chan a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | Direct <a>MonadPlus</a> equivalent of <a>filter</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   The <a>filter</a> function is just <a>mfilter</a> specialized to the
--   list monad:
--   
--   <pre>
--   <a>filter</a> = ( <a>mfilter</a> :: (a -&gt; Bool) -&gt; [a] -&gt; [a] )
--   </pre>
--   
--   An example using <a>mfilter</a> with the <a>Maybe</a> monad:
--   
--   <pre>
--   &gt;&gt;&gt; mfilter odd (Just 1)
--   Just 1
--   &gt;&gt;&gt; mfilter odd (Just 2)
--   Nothing
--   </pre>
mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a

-- | Strict version of <a>&lt;$&gt;</a>.
(<$!>) :: Monad m => (a -> b) -> m a -> m b
infixl 4 <$!>

-- | The reverse of <a>when</a>.
unless :: Applicative f => Bool -> f () -> f ()

-- | Like <a>replicateM</a>, but discards the result.
replicateM_ :: Applicative m => Int -> m a -> m ()

-- | Like <a>foldM</a>, but discards the result.
foldM_ :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()

-- | The <a>foldM</a> function is analogous to <a>foldl</a>, except that
--   its result is encapsulated in a monad. Note that <a>foldM</a> works
--   from left-to-right over the list arguments. This could be an issue
--   where <tt>(<a>&gt;&gt;</a>)</tt> and the `folded function' are not
--   commutative.
--   
--   <pre>
--   foldM f a1 [x1, x2, ..., xm]
--   
--   ==
--   
--   do
--     a2 &lt;- f a1 x1
--     a3 &lt;- f a2 x2
--     ...
--     f am xm
--   </pre>
--   
--   If right-to-left evaluation is required, the input list should be
--   reversed.
--   
--   Note: <a>foldM</a> is the same as <a>foldlM</a>
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | <a>zipWithM_</a> is the extension of <a>zipWithM</a> which ignores the
--   final result.
zipWithM_ :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

-- | The <a>zipWithM</a> function generalizes <a>zipWith</a> to arbitrary
--   applicative functors.
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]

-- | Repeat an action indefinitely.
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>forever</a> is to process input from network
--   sockets, <a>Handle</a>s, and channels (e.g. <a>MVar</a> and
--   <a>Chan</a>).
--   
--   For example, here is how we might implement an <a>echo server</a>,
--   using <a>forever</a> both to listen for client connections on a
--   network socket and to echo client input on client connection handles:
--   
--   <pre>
--   echoServer :: Socket -&gt; IO ()
--   echoServer socket = <a>forever</a> $ do
--     client &lt;- accept socket
--     <a>forkFinally</a> (echo client) (\_ -&gt; hClose client)
--     where
--       echo :: Handle -&gt; IO ()
--       echo client = <a>forever</a> $
--         hGetLine client &gt;&gt;= hPutStrLn client
--   </pre>
forever :: Applicative f => f a -> f b

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Left-to-right composition of Kleisli arrows.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | This generalizes the list-based <a>filter</a> function.
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]

-- | <a>forM</a> is <a>mapM</a> with its arguments flipped. For a version
--   that ignores the results see <a>forM_</a>.
forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)

-- | <a>for</a> is <a>traverse</a> with its arguments flipped. For a
--   version that ignores the results see <a>for_</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | One or none.
optional :: Alternative f => f a -> f (Maybe a)

-- | The basic arrow class.
--   
--   Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre><a>arr</a> id = <a>id</a></pre></li>
--   <li><pre><a>arr</a> (f &gt;&gt;&gt; g) = <a>arr</a> f &gt;&gt;&gt;
--   <a>arr</a> g</pre></li>
--   <li><pre><a>first</a> (<a>arr</a> f) = <a>arr</a> (<a>first</a>
--   f)</pre></li>
--   <li><pre><a>first</a> (f &gt;&gt;&gt; g) = <a>first</a> f &gt;&gt;&gt;
--   <a>first</a> g</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> <a>fst</a> =
--   <a>arr</a> <a>fst</a> &gt;&gt;&gt; f</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> (<a>id</a> *** g) =
--   <a>arr</a> (<a>id</a> *** g) &gt;&gt;&gt; <a>first</a> f</pre></li>
--   <li><pre><a>first</a> (<a>first</a> f) &gt;&gt;&gt; <a>arr</a> assoc =
--   <a>arr</a> assoc &gt;&gt;&gt; <a>first</a> f</pre></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assoc ((a,b),c) = (a,(b,c))
--   </pre>
--   
--   The other combinators have sensible default definitions, which may be
--   overridden for efficiency.
class Category a => Arrow (a :: Type -> Type -> Type)

-- | Send the first component of the input through the argument arrow, and
--   copy the rest unchanged to the output.
first :: Arrow a => a b c -> a (b, d) (c, d)

-- | A mirror image of <a>first</a>.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
second :: Arrow a => a b c -> a (d, b) (d, c)

-- | Split the input between the two argument arrows and combine their
--   output. Note that this is in general not a functor.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
infixr 3 ***
infixr 3 &&&

-- | Identity functor and monad. (a non-strict monad)
newtype Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a

-- | A handle managing output to the Haskell program's standard error
--   channel.
stderr :: Handle

-- | A handle managing input from the Haskell program's standard input
--   channel.
stdin :: Handle

-- | Write the supplied value into a <a>TVar</a>.
writeTVar :: TVar a -> a -> STM ()

-- | Return the current value stored in a <a>TVar</a>.
readTVar :: TVar a -> STM a

-- | Create a new <a>TVar</a> holding a value supplied
newTVar :: a -> STM (TVar a)

-- | A monad supporting atomic memory transactions.
data STM a

-- | Shared memory locations that support atomic memory transactions.
data TVar a

-- | Superclass for asynchronous exceptions.
data SomeAsyncException
SomeAsyncException :: e -> SomeAsyncException

-- | Defines the exit codes that a program can return.
data ExitCode

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode

-- | A mode that determines the effect of <a>hSeek</a> <tt>hdl mode i</tt>.
data SeekMode

-- | A mutable variable in the <a>IO</a> monad
data IORef a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Exceptions that occur in the <tt>IO</tt> monad. An
--   <tt>IOException</tt> records a more specific error type, a descriptive
--   string and maybe the handle that was used when the error was flagged.
data IOException

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The <a>Const</a> functor.
newtype Const a (b :: k)
Const :: a -> Const a (b :: k)
[getConst] :: Const a (b :: k) -> a

-- | <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
infix 4 `notElem`

-- | Determines whether all elements of the structure satisfy the
--   predicate.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Determines whether any element of the structure satisfies the
--   predicate.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | <a>or</a> returns the disjunction of a container of Bools. For the
--   result to be <a>False</a>, the container must be finite; <a>True</a>,
--   however, results from a <a>True</a> value finitely far from the left
--   end.
or :: Foldable t => t Bool -> Bool

-- | <a>and</a> returns the conjunction of a container of Bools. For the
--   result to be <a>True</a>, the container must be finite; <a>False</a>,
--   however, results from a <a>False</a> value finitely far from the left
--   end.
and :: Foldable t => t Bool -> Bool

-- | Map a function over all the elements of a container and concatenate
--   the resulting lists.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | The concatenation of all the elements of a container of lists.
concat :: Foldable t => t [a] -> [a]

-- | The sum of a collection of actions, generalizing <a>concat</a>. As of
--   base 4.8.0.0, <a>msum</a> is just <a>asum</a>, specialized to
--   <a>MonadPlus</a>.
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a

-- | The sum of a collection of actions, generalizing <a>concat</a>.
--   
--   <pre>
--   &gt;&gt;&gt; asum [Just "Hello", Nothing, Just "World"]
--   Just "Hello"
--   </pre>
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Evaluate each monadic action in the structure from left to right, and
--   ignore the results. For a version that doesn't ignore the results see
--   <a>sequence</a>.
--   
--   As of base 4.8.0.0, <a>sequence_</a> is just <a>sequenceA_</a>,
--   specialized to <a>Monad</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Evaluate each action in the structure from left to right, and ignore
--   the results. For a version that doesn't ignore the results see
--   <a>sequenceA</a>.
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | <a>forM_</a> is <a>mapM_</a> with its arguments flipped. For a version
--   that doesn't ignore the results see <a>forM</a>.
--   
--   As of base 4.8.0.0, <a>forM_</a> is just <a>for_</a>, specialized to
--   <a>Monad</a>.
forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()

-- | Map each element of a structure to a monadic action, evaluate these
--   actions from left to right, and ignore the results. For a version that
--   doesn't ignore the results see <a>mapM</a>.
--   
--   As of base 4.8.0.0, <a>mapM_</a> is just <a>traverse_</a>, specialized
--   to <a>Monad</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | <a>for_</a> is <a>traverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>.
--   
--   <pre>
--   &gt;&gt;&gt; for_ [1..4] print
--   1
--   2
--   3
--   4
--   </pre>
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Map each element of a structure to an action, evaluate these actions
--   from left to right, and ignore the results. For a version that doesn't
--   ignore the results see <a>traverse</a>.
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | <a>unwords</a> is an inverse operation to <a>words</a>. It joins words
--   with separating spaces.
--   
--   <pre>
--   &gt;&gt;&gt; unwords ["Lorem", "ipsum", "dolor"]
--   "Lorem ipsum dolor"
--   </pre>
unwords :: [String] -> String

-- | <a>words</a> breaks a string up into a list of words, which were
--   delimited by white space.
--   
--   <pre>
--   &gt;&gt;&gt; words "Lorem ipsum\ndolor"
--   ["Lorem","ipsum","dolor"]
--   </pre>
words :: String -> [String]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
--   
--   <pre>
--   &gt;&gt;&gt; unlines ["Hello", "World", "!"]
--   "Hello\nWorld\n!\n"
--   </pre>
unlines :: [String] -> String

-- | <a>lines</a> breaks a string up into a list of strings at newline
--   characters. The resulting strings do not contain newlines.
--   
--   Note that after splitting the string at newline characters, the last
--   part of the string is considered a line even if it doesn't end with a
--   newline. For example,
--   
--   <pre>
--   &gt;&gt;&gt; lines ""
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "\n"
--   [""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n"
--   ["one"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\n\n"
--   ["one",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo"
--   ["one","two"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "one\ntwo\n"
--   ["one","two"]
--   </pre>
--   
--   Thus <tt><a>lines</a> s</tt> contains at least as many elements as
--   newlines in <tt>s</tt>.
lines :: String -> [String]

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "123" :: Maybe Int
--   Just 123
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; readMaybe "hello" :: Maybe Int
--   Nothing
--   </pre>
readMaybe :: Read a => String -> Maybe a

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isLeft (Left "foo")
--   True
--   
--   &gt;&gt;&gt; isLeft (Right 3)
--   False
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isLeft</a> to write a very simple error-reporting function that
--   does absolutely nothing in the case of success, and outputs "ERROR" if
--   any error occurred.
--   
--   This example shows how <a>isLeft</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isLeft e) $ putStrLn "ERROR"
--   
--   &gt;&gt;&gt; report (Right 1)
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   ERROR
--   </pre>
isLeft :: Either a b -> Bool

-- | Partitions a list of <a>Either</a> into two lists. All the <a>Left</a>
--   elements are extracted, in order, to the first component of the
--   output. Similarly the <a>Right</a> elements are extracted to the
--   second component of the output.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list
--   (["foo","bar","baz"],[3,7])
--   </pre>
--   
--   The pair returned by <tt><a>partitionEithers</a> x</tt> should be the
--   same pair as <tt>(<a>lefts</a> x, <a>rights</a> x)</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; partitionEithers list == (lefts list, rights list)
--   True
--   </pre>
partitionEithers :: [Either a b] -> ([a], [b])

-- | Extracts from a list of <a>Either</a> all the <a>Right</a> elements.
--   All the <a>Right</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; rights list
--   [3,7]
--   </pre>
rights :: [Either a b] -> [b]

-- | Extracts from a list of <a>Either</a> all the <a>Left</a> elements.
--   All the <a>Left</a> elements are extracted in order.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; let list = [ Left "foo", Right 3, Left "bar", Right 7, Left "baz" ]
--   
--   &gt;&gt;&gt; lefts list
--   ["foo","bar","baz"]
--   </pre>
lefts :: [Either a b] -> [a]

-- | <pre>
--   comparing p x y = compare (p x) (p y)
--   </pre>
--   
--   Useful combinator for use in conjunction with the <tt>xxxBy</tt>
--   family of functions from <a>Data.List</a>, for example:
--   
--   <pre>
--   ... sortBy (comparing fst) ...
--   </pre>
comparing :: Ord a => (b -> a) -> b -> b -> Ordering

-- | The <a>Down</a> type allows you to reverse sort order conveniently. A
--   value of type <tt><a>Down</a> a</tt> contains a value of type
--   <tt>a</tt> (represented as <tt><a>Down</a> a</tt>). If <tt>a</tt> has
--   an <tt><a>Ord</a></tt> instance associated with it then comparing two
--   values thus wrapped will give you the opposite of their normal sort
--   order. This is particularly useful when sorting in generalised list
--   comprehensions, as in: <tt>then sortWith by <a>Down</a> x</tt>
newtype Down a
Down :: a -> Down a

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k)
Proxy :: Proxy (t :: k)

-- | Left-to-right composition
(>>>) :: forall k cat (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
infixr 1 >>>

-- | A class for categories. Instances should satisfy the laws
--   
--   <ul>
--   <li><i>Right identity</i> <tt>f <a>.</a> <a>id</a> = f</tt></li>
--   <li><i>Left identity</i> <tt><a>id</a> <a>.</a> f = f</tt></li>
--   <li><i>Associativity</i> <tt>f <a>.</a> (g <a>.</a> h) = (f <a>.</a>
--   g) <a>.</a> h</tt></li>
--   </ul>
class Category (cat :: k -> k -> Type)

-- | See <a>openFile</a>
data IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
class Storable a

-- | Reverse order of bytes in <a>Word64</a>.
byteSwap64 :: Word64 -> Word64

-- | Reverse order of bytes in <a>Word32</a>.
byteSwap32 :: Word32 -> Word32

-- | Swap bytes in <a>Word16</a>.
byteSwap16 :: Word16 -> Word16

-- | <tt><a>lcm</a> x y</tt> is the smallest positive integer that both
--   <tt>x</tt> and <tt>y</tt> divide.
lcm :: Integral a => a -> a -> a

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>. (That is, the common divisor
--   that is "greatest" in the divisibility preordering.)
--   
--   Note: Since for signed fixed-width integer types, <tt><a>abs</a>
--   <a>minBound</a> &lt; 0</tt>, the result may be negative if one of the
--   arguments is <tt><a>minBound</a></tt> (and necessarily is if the other
--   is <tt>0</tt> or <tt><a>minBound</a></tt>) for such types.
gcd :: Integral a => a -> a -> a

-- | raise a number to an integral power
(^^) :: (Fractional a, Integral b) => a -> b -> a
infixr 8 ^^

-- | raise a number to a non-negative integral power
(^) :: (Num a, Integral b) => a -> b -> a
infixr 8 ^
odd :: Integral a => a -> Bool
even :: Integral a => a -> Bool

-- | Return the value computed by a state thread. The <tt>forall</tt>
--   ensures that the internal state used by the <a>ST</a> computation is
--   inaccessible to the rest of the program.
runST :: (forall s. () => ST s a) -> a

-- | <i>O(min(m,n))</i>. <a>zipWith</a> generalises <a>zip</a> by zipping
--   with the function given as the first argument, instead of a tupling
--   function. For example, <tt><a>zipWith</a> (+)</tt> is applied to two
--   lists to produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | <i>O(n)</i>. <a>lookup</a> <tt>key assocs</tt> looks up a key in an
--   association list.
--   
--   <pre>
--   &gt;&gt;&gt; lookup 2 [(1, "first"), (2, "second"), (3, "third")]
--   Just "second"
--   </pre>
lookup :: Eq a => a -> [(a, b)] -> Maybe b

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>xs</tt> of elements that <i>do not satisfy</i>
--   <tt>p</tt> and second element is the remainder of the list:
--   
--   <pre>
--   break (&gt; 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
--   break (&lt; 9) [1,2,3] == ([],[1,2,3])
--   break (&gt; 9) [1,2,3] == ([1,2,3],[])
--   </pre>
--   
--   <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a list <tt>xs</tt>,
--   returns a tuple where first element is longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt> and second element
--   is the remainder of the list:
--   
--   <pre>
--   span (&lt; 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
--   span (&lt; 9) [1,2,3] == ([1,2,3],[])
--   span (&lt; 0) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   <a>span</a> <tt>p xs</tt> is equivalent to <tt>(<a>takeWhile</a> p xs,
--   <a>dropWhile</a> p xs)</tt>
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a list
--   <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>:
--   
--   <pre>
--   takeWhile (&lt; 3) [1,2,3,4,1,2,3,4] == [1,2]
--   takeWhile (&lt; 9) [1,2,3] == [1,2,3]
--   takeWhile (&lt; 0) [1,2,3] == []
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <a>replicate</a> <tt>n x</tt> is a list of length <tt>n</tt> with
--   <tt>x</tt> the value of every element. It is an instance of the more
--   general <a>genericReplicate</a>, in which <tt>n</tt> may be of any
--   integral type.
replicate :: Int -> a -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is <a>Nothing</a>,
--   no element is added on to the result list. If it is <tt><a>Just</a>
--   b</tt>, then <tt>b</tt> is included in the result list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Using <tt><a>mapMaybe</a> f x</tt> is a shortcut for
--   <tt><a>catMaybes</a> $ <a>map</a> f x</tt> in most cases:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; let readMaybeInt = readMaybe :: String -&gt; Maybe Int
--   
--   &gt;&gt;&gt; mapMaybe readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   
--   &gt;&gt;&gt; catMaybes $ map readMaybeInt ["1", "Foo", "3"]
--   [1,3]
--   </pre>
--   
--   If we map the <a>Just</a> constructor, the entire list should be
--   returned:
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe Just [1,2,3]
--   [1,2,3]
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <a>Just</a> values.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; catMaybes [Just 1, Nothing, Just 3]
--   [1,3]
--   </pre>
--   
--   When constructing a list of <a>Maybe</a> values, <a>catMaybes</a> can
--   be used to return all of the "success" results (if the list is the
--   result of a <a>map</a>, then <a>mapMaybe</a> would be more
--   appropriate):
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [Just 1,Nothing,Just 3]
--   
--   &gt;&gt;&gt; catMaybes $ [readMaybe x :: Maybe Int | x &lt;- ["1", "Foo", "3"] ]
--   [1,3]
--   </pre>
catMaybes :: [Maybe a] -> [a]

-- | The <a>listToMaybe</a> function returns <a>Nothing</a> on an empty
--   list or <tt><a>Just</a> a</tt> where <tt>a</tt> is the first element
--   of the list.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [9]
--   Just 9
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; listToMaybe [1,2,3]
--   Just 1
--   </pre>
--   
--   Composing <a>maybeToList</a> with <a>listToMaybe</a> should be the
--   identity on singleton/empty lists:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [5]
--   [5]
--   
--   &gt;&gt;&gt; maybeToList $ listToMaybe []
--   []
--   </pre>
--   
--   But not on lists with more than one element:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList $ listToMaybe [1,2,3]
--   [1]
--   </pre>
listToMaybe :: [a] -> Maybe a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <a>Nothing</a> or a singleton list when given <a>Just</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList (Just 7)
--   [7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybeToList Nothing
--   []
--   </pre>
--   
--   One can use <a>maybeToList</a> to avoid pattern matching when combined
--   with a function that (safely) works on lists:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "3")
--   3
--   
--   &gt;&gt;&gt; sum $ maybeToList (readMaybe "")
--   0
--   </pre>
maybeToList :: Maybe a -> [a]

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>maybe</a> function takes a default value, a function, and a
--   <a>Maybe</a> value. If the <a>Maybe</a> value is <a>Nothing</a>, the
--   function returns the default value. Otherwise, it applies the function
--   to the value inside the <a>Just</a> and returns the result.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maybe False odd Nothing
--   False
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we succeed,
--   return twice the integer; that is, apply <tt>(*2)</tt> to it. If
--   instead we fail to parse an integer, return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "5")
--   10
--   
--   &gt;&gt;&gt; maybe 0 (*2) (readMaybe "")
--   0
--   </pre>
--   
--   Apply <a>show</a> to a <tt>Maybe Int</tt>. If we have <tt>Just n</tt>,
--   we want to show the underlying <a>Int</a> <tt>n</tt>. But if we have
--   <a>Nothing</a>, we return the empty string instead of (for example)
--   "Nothing":
--   
--   <pre>
--   &gt;&gt;&gt; maybe "" show (Just 5)
--   "5"
--   
--   &gt;&gt;&gt; maybe "" show Nothing
--   ""
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> x y p</tt>
--   evaluates to <tt>x</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>y</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then y else x</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> x y p</tt> and <tt>if p then y else
--   x</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; x = "bar"; y = "foo"
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   </pre>
bool :: a -> a -> Bool -> a

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<a>compare</a> `on`
--   <a>fst</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`

-- | <tt><a>fix</a> f</tt> is the least fixed point of the function
--   <tt>f</tt>, i.e. the least defined <tt>x</tt> such that <tt>f x =
--   x</tt>.
--   
--   For example, we can write the factorial function using direct
--   recursion as
--   
--   <pre>
--   &gt;&gt;&gt; let fac n = if n &lt;= 1 then 1 else n * fac (n-1) in fac 5
--   120
--   </pre>
--   
--   This uses the fact that Haskell’s <tt>let</tt> introduces recursive
--   bindings. We can rewrite this definition using <a>fix</a>,
--   
--   <pre>
--   &gt;&gt;&gt; fix (\rec n -&gt; if n &lt;= 1 then 1 else n * rec (n-1)) 5
--   120
--   </pre>
--   
--   Instead of making a recursive call, we introduce a dummy parameter
--   <tt>rec</tt>; when used within <a>fix</a>, this parameter then refers
--   to <a>fix</a> argument, hence the recursion is reintroduced.
fix :: (a -> a) -> a

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | An infix synonym for <a>fmap</a>.
--   
--   The name of this operator is an allusion to <a>$</a>. Note the
--   similarities between their types:
--   
--   <pre>
--    ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
--   (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   </pre>
--   
--   Whereas <a>$</a> is function application, <a>&lt;$&gt;</a> is function
--   application lifted over a <a>Functor</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Convert from a <tt><a>Maybe</a> <a>Int</a></tt> to a <tt><a>Maybe</a>
--   <a>String</a></tt> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Nothing
--   Nothing
--   
--   &gt;&gt;&gt; show &lt;$&gt; Just 3
--   Just "3"
--   </pre>
--   
--   Convert from an <tt><a>Either</a> <a>Int</a> <a>Int</a></tt> to an
--   <tt><a>Either</a> <a>Int</a></tt> <a>String</a> using <a>show</a>:
--   
--   <pre>
--   &gt;&gt;&gt; show &lt;$&gt; Left 17
--   Left 17
--   
--   &gt;&gt;&gt; show &lt;$&gt; Right 17
--   Right "17"
--   </pre>
--   
--   Double each element of a list:
--   
--   <pre>
--   &gt;&gt;&gt; (*2) &lt;$&gt; [1,2,3]
--   [2,4,6]
--   </pre>
--   
--   Apply <a>even</a> to the second element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; even &lt;$&gt; (2,2)
--   (2,True)
--   </pre>
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | <a>uncurry</a> converts a curried function to a function on pairs.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry (+) (1,2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncurry ($) (show, 1)
--   "1"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (uncurry max) [(1,2), (3,4), (6,8)]
--   [2,4,8]
--   </pre>
uncurry :: (a -> b -> c) -> (a, b) -> c

-- | <a>curry</a> converts an uncurried function to a curried function.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; curry fst 1 2
--   1
--   </pre>
curry :: ((a, b) -> c) -> a -> b -> c

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a box, which may be empty or full.
data MVar a

-- | the same as <tt><a>flip</a> (<a>-</a>)</tt>.
--   
--   Because <tt>-</tt> is treated specially in the Haskell grammar,
--   <tt>(-</tt> <i>e</i><tt>)</tt> is not a section, but an application of
--   prefix negation. However, <tt>(<a>subtract</a></tt>
--   <i>exp</i><tt>)</tt> is equivalent to the disallowed section.
subtract :: Num a => a -> a -> a

-- | <a>asTypeOf</a> is a type-restricted version of <a>const</a>. It is
--   usually used as an infix operator, and its typing forces its first
--   argument (which is usually overloaded) to have the same type as the
--   second.
asTypeOf :: a -> a -> a

-- | Strict (call-by-value) application operator. It takes a function and
--   an argument, evaluates the argument to weak head normal form (WHNF),
--   then calls the function with that value.
($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
infixr 0 $!

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <tt>const x</tt> is a unary function which evaluates to <tt>x</tt> for
--   all inputs.
--   
--   <pre>
--   &gt;&gt;&gt; const 42 "hello"
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (const 42) [0..3]
--   [42,42,42,42]
--   </pre>
const :: a -> b -> a

-- | Promote a function to a monad, scanning the monadic arguments from
--   left to right. For example,
--   
--   <pre>
--   liftM2 (+) [0,1] [0,2] = [0,2,1,3]
--   liftM2 (+) (Just 1) Nothing = Nothing
--   </pre>
liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r

-- | Conditional execution of <a>Applicative</a> expressions. For example,
--   
--   <pre>
--   when debug (putStrLn "Debugging")
--   </pre>
--   
--   will output the string <tt>Debugging</tt> if the Boolean value
--   <tt>debug</tt> is <a>True</a>, and otherwise do nothing.
when :: Applicative f => Bool -> f () -> f ()

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Lift a ternary function to actions.
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d

-- | Lift a function to actions. This function may be used as a value for
--   <a>fmap</a> in a <a>Functor</a> instance.
liftA :: Applicative f => (a -> b) -> f a -> f b

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => a

-- | <a>error</a> stops execution and displays an error message.
error :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack => [Char] -> a

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException
SomeException :: e -> SomeException

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Boolean "not"
not :: Bool -> Bool

-- | <i>O(n)</i>. Convert a <a>ShortByteString</a> into a
--   <a>ByteString</a>.
fromShort :: ShortByteString -> ByteString

-- | A compact representation of a <a>Word8</a> vector.
--   
--   It has a lower memory overhead than a <a>ByteString</a> and and does
--   not contribute to heap fragmentation. It can be converted to or from a
--   <a>ByteString</a> (at the cost of copying the string data). It
--   supports very few other operations.
--   
--   It is suitable for use as an internal representation for code that
--   needs to keep many short strings in memory, but it <i>should not</i>
--   be used as an interchange type. That is, it should not generally be
--   used in public APIs. The <a>ByteString</a> type is usually more
--   suitable for use in interfaces; it is more flexible and it supports a
--   wide range of operations.
data ShortByteString

-- | <a>Builder</a>s denote sequences of bytes. They are <a>Monoid</a>s
--   where <a>mempty</a> is the zero-length sequence and <a>mappend</a> is
--   concatenation, which runs in <i>O(1)</i>.
data Builder

-- | <i>O(n)</i>. Convert a <a>ByteString</a> into a
--   <a>ShortByteString</a>.
--   
--   This makes a copy, so does not retain the input string.
toShort :: ByteString -> ShortByteString

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
newtype ReaderT r (m :: Type -> Type) a
ReaderT :: (r -> m a) -> ReaderT r (m :: Type -> Type) a
[runReaderT] :: ReaderT r (m :: Type -> Type) a -> r -> m a

-- | Monads which allow their actions to be run in <a>IO</a>.
--   
--   While <a>MonadIO</a> allows an <a>IO</a> action to be lifted into
--   another monad, this class captures the opposite concept: allowing you
--   to capture the monadic context. Note that, in order to meet the laws
--   given below, the intuition is that a monad must have no monadic state,
--   but may have monadic context. This essentially limits
--   <a>MonadUnliftIO</a> to <a>ReaderT</a> and <a>IdentityT</a>
--   transformers on top of <a>IO</a>.
--   
--   Laws. For any value <tt>u</tt> returned by <a>askUnliftIO</a>, it must
--   meet the monad transformer laws as reformulated for
--   <tt>MonadUnliftIO</tt>:
--   
--   <ul>
--   <li><pre>unliftIO u . return = return</pre></li>
--   <li><pre>unliftIO u (m &gt;&gt;= f) = unliftIO u m &gt;&gt;= unliftIO
--   u . f</pre></li>
--   </ul>
--   
--   The third is a currently nameless law which ensures that the current
--   context is preserved.
--   
--   <ul>
--   <li><pre>askUnliftIO &gt;&gt;= (u -&gt; liftIO (unliftIO u m)) =
--   m</pre></li>
--   </ul>
--   
--   If you have a name for this, please submit it in a pull request for
--   great glory.
class MonadIO m => MonadUnliftIO (m :: Type -> Type)

-- | Capture the current monadic context, providing the ability to run
--   monadic actions in <a>IO</a>.
--   
--   See <a>UnliftIO</a> for an explanation of why we need a helper
--   datatype here.
askUnliftIO :: MonadUnliftIO m => m (UnliftIO m)

-- | Convenience function for capturing the monadic context and running an
--   <a>IO</a> action with a runner function. The runner function is used
--   to run a monadic action <tt>m</tt> in <tt>IO</tt>.
withRunInIO :: MonadUnliftIO m => ((forall a. () => m a -> IO a) -> IO b) -> m b

-- | Class of monads which can perform primitive state-transformer actions
class Monad m => PrimMonad (m :: Type -> Type) where {
    
    -- | State token type
    type family PrimState (m :: Type -> Type);
}

-- | Execute a primitive operation
primitive :: PrimMonad m => (State# (PrimState m) -> (# State# (PrimState m), a #)) -> m a

-- | State token type
type family PrimState (m :: Type -> Type)

-- | The class of monad transformers. Instances should satisfy the
--   following laws, which state that <a>lift</a> is a monad
--   transformation:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
class MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | A class for monads in which exceptions may be thrown.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   throwM e &gt;&gt; x = throwM e
--   </pre>
--   
--   In other words, throwing an exception short-circuits the rest of the
--   monadic computation.
class Monad m => MonadThrow (m :: Type -> Type)

-- | Throw an exception. Note that this throws when this action is run in
--   the monad <tt>m</tt>, not when it is applied. It is a generalization
--   of <a>Control.Exception</a>'s <a>throwIO</a>.
--   
--   Should satisfy the law:
--   
--   <pre>
--   throwM e &gt;&gt; f = throwM e
--   </pre>
throwM :: (MonadThrow m, Exception e) => e -> m a

-- | A map of integers to values <tt>a</tt>.
data IntMap a

-- | A set of integers.
data IntSet

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
--   
--   The <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which
--   prefers values from the left operand. If <tt>m1</tt> maps a key
--   <tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key
--   to a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;
--   m2</tt> maps <tt>k</tt> to <tt>a1</tt>.
data Map k a

-- | General-purpose finite sequences.
data Seq a

-- | A set of values <tt>a</tt>.
data Set a

-- | a variant of <a>deepseq</a> that is useful in some circumstances:
--   
--   <pre>
--   force x = x `deepseq` x
--   </pre>
--   
--   <tt>force x</tt> fully evaluates <tt>x</tt>, and then returns it. Note
--   that <tt>force x</tt> only performs evaluation when the value of
--   <tt>force x</tt> itself is demanded, so essentially it turns shallow
--   evaluation into deep evaluation.
--   
--   <a>force</a> can be conveniently used in combination with
--   <tt>ViewPatterns</tt>:
--   
--   <pre>
--   {-# LANGUAGE BangPatterns, ViewPatterns #-}
--   import Control.DeepSeq
--   
--   someFun :: ComplexData -&gt; SomeResult
--   someFun (force -&gt; !arg) = {- 'arg' will be fully evaluated -}
--   </pre>
--   
--   Another useful application is to combine <a>force</a> with
--   <a>evaluate</a> in order to force deep evaluation relative to other
--   <a>IO</a> operations:
--   
--   <pre>
--   import Control.Exception (evaluate)
--   import Control.DeepSeq
--   
--   main = do
--     result &lt;- evaluate $ force $ pureComputation
--     {- 'result' will be fully evaluated at this point -}
--     return ()
--   </pre>
--   
--   Finally, here's an exception safe variant of the <tt>readFile'</tt>
--   example:
--   
--   <pre>
--   readFile' :: FilePath -&gt; IO String
--   readFile' fn = bracket (openFile fn ReadMode) hClose $ \h -&gt;
--                          evaluate . force =&lt;&lt; hGetContents h
--   </pre>
force :: NFData a => a -> a

-- | the deep analogue of <a>$!</a>. In the expression <tt>f $!! x</tt>,
--   <tt>x</tt> is fully evaluated before the function <tt>f</tt> is
--   applied to it.
($!!) :: NFData a => (a -> b) -> a -> b
infixr 0 $!!

-- | <a>deepseq</a>: fully evaluates the first argument, before returning
--   the second.
--   
--   The name <a>deepseq</a> is used to illustrate the relationship to
--   <a>seq</a>: where <a>seq</a> is shallow in the sense that it only
--   evaluates the top level of its argument, <a>deepseq</a> traverses the
--   entire data structure evaluating it completely.
--   
--   <a>deepseq</a> can be useful for forcing pending exceptions,
--   eradicating space leaks, or forcing lazy I/O to happen. It is also
--   useful in conjunction with parallel Strategies (see the
--   <tt>parallel</tt> package).
--   
--   There is no guarantee about the ordering of evaluation. The
--   implementation may evaluate the components of the structure in any
--   order or in parallel. To impose an actual order on evaluation, use
--   <tt>pseq</tt> from <a>Control.Parallel</a> in the <tt>parallel</tt>
--   package.
deepseq :: NFData a => a -> b -> b

-- | A class of types that can be fully evaluated.
class NFData a

-- | <a>rnf</a> should reduce its argument to normal form (that is, fully
--   evaluate all sub-components), and then return <tt>()</tt>.
--   
--   <h3><a>Generic</a> <a>NFData</a> deriving</h3>
--   
--   Starting with GHC 7.2, you can automatically derive instances for
--   types possessing a <a>Generic</a> instance.
--   
--   Note: <a>Generic1</a> can be auto-derived starting with GHC 7.4
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics (Generic, Generic1)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1)
--   
--   instance NFData a =&gt; NFData (Foo a)
--   instance NFData1 Foo
--   
--   data Colour = Red | Green | Blue
--                 deriving Generic
--   
--   instance NFData Colour
--   </pre>
--   
--   Starting with GHC 7.10, the example above can be written more
--   concisely by enabling the new <tt>DeriveAnyClass</tt> extension:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}
--   
--   import GHC.Generics (Generic)
--   import Control.DeepSeq
--   
--   data Foo a = Foo a String
--                deriving (Eq, Generic, Generic1, NFData, NFData1)
--   
--   data Colour = Red | Green | Blue
--                 deriving (Generic, NFData)
--   </pre>
--   
--   <h3>Compatibility with previous <tt>deepseq</tt> versions</h3>
--   
--   Prior to version 1.4.0.0, the default implementation of the <a>rnf</a>
--   method was defined as
--   
--   <pre>
--   <a>rnf</a> a = <a>seq</a> a ()
--   </pre>
--   
--   However, starting with <tt>deepseq-1.4.0.0</tt>, the default
--   implementation is based on <tt>DefaultSignatures</tt> allowing for
--   more accurate auto-derived <a>NFData</a> instances. If you need the
--   previously used exact default <a>rnf</a> method implementation
--   semantics, use
--   
--   <pre>
--   instance NFData Colour where rnf x = seq x ()
--   </pre>
--   
--   or alternatively
--   
--   <pre>
--   instance NFData Colour where rnf = rwhnf
--   </pre>
--   
--   or
--   
--   <pre>
--   {-# LANGUAGE BangPatterns #-}
--   instance NFData Colour where rnf !_ = ()
--   </pre>
rnf :: NFData a => a -> ()

-- | The class of types that can be converted to a hash value.
--   
--   Minimal implementation: <a>hashWithSalt</a>.
class Hashable a

-- | A map from keys to values. A map cannot contain duplicate keys; each
--   key can map to at most one value.
data HashMap k v
class (Vector Vector a, MVector MVector a) => Unbox a

-- | A set of values. A set cannot contain duplicate values.
data HashSet a

-- | Boxed vectors, supporting efficient slicing.
data Vector a

-- | The parameterizable reader monad.
--   
--   Computations are functions of a shared environment.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
type Reader r = ReaderT r Identity

-- | <a>lens</a> creates a <a>Lens</a> from a getter and a setter. The
--   resulting lens isn't the most effective one (because of having to
--   traverse the structure twice when modifying), but it shouldn't matter
--   much.
--   
--   A (partial) lens for list indexing:
--   
--   <pre>
--   ix :: Int -&gt; <a>Lens'</a> [a] a
--   ix i = <a>lens</a> (<a>!!</a> i)                                   -- getter
--               (\s b -&gt; take i s ++ b : drop (i+1) s)   -- setter
--   </pre>
--   
--   Usage:
--   
--   <pre>
--   &gt;&gt;&gt; [1..9] <a>^.</a> ix 3
--   4
--   
--   &gt;&gt;&gt; [1..9] &amp; ix 3 <a>%~</a> negate
--   [1,2,3,-4,5,6,7,8,9]
--   </pre>
--   
--   When getting, the setter is completely unused; when setting, the
--   getter is unused. Both are used only when the value is being modified.
--   For instance, here we define a lens for the 1st element of a list, but
--   instead of a legitimate getter we use <a>undefined</a>. Then we use
--   the resulting lens for <i>setting</i> and it works, which proves that
--   the getter wasn't used:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; lens undefined (\s b -&gt; b : tail s) .~ 10
--   [10,2,3]
--   </pre>
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b

-- | <a>to</a> creates a getter from any function:
--   
--   <pre>
--   a <a>^.</a> <a>to</a> f = f a
--   </pre>
--   
--   It's most useful in chains, because it lets you mix lenses and
--   ordinary functions. Suppose you have a record which comes from some
--   third-party library and doesn't have any lens accessors. You want to
--   do something like this:
--   
--   <pre>
--   value ^. _1 . field . at 2
--   </pre>
--   
--   However, <tt>field</tt> isn't a getter, and you have to do this
--   instead:
--   
--   <pre>
--   field (value ^. _1) ^. at 2
--   </pre>
--   
--   but now <tt>value</tt> is in the middle and it's hard to read the
--   resulting code. A variant with <a>to</a> is prettier and more
--   readable:
--   
--   <pre>
--   value ^. _1 . to field . at 2
--   </pre>
to :: (s -> a) -> SimpleGetter s a

-- | (<a>^.</a>) applies a getter to a value; in other words, it gets a
--   value out of a structure using a getter (which can be a lens,
--   traversal, fold, etc.).
--   
--   Getting 1st field of a tuple:
--   
--   <pre>
--   (<a>^.</a> <a>_1</a>) :: (a, b) -&gt; a
--   (<a>^.</a> <a>_1</a>) = <a>fst</a>
--   </pre>
--   
--   When (<a>^.</a>) is used with a traversal, it combines all results
--   using the <a>Monoid</a> instance for the resulting type. For instance,
--   for lists it would be simple concatenation:
--   
--   <pre>
--   &gt;&gt;&gt; ("str","ing") ^. each
--   "string"
--   </pre>
--   
--   The reason for this is that traversals use <a>Applicative</a>, and the
--   <a>Applicative</a> instance for <a>Const</a> uses monoid concatenation
--   to combine “effects” of <a>Const</a>.
--   
--   A non-operator version of (<a>^.</a>) is called <tt>view</tt>, and
--   it's a bit more general than (<a>^.</a>) (it works in
--   <tt>MonadReader</tt>). If you need the general version, you can get it
--   from <a>microlens-mtl</a>; otherwise there's <a>view</a> available in
--   <a>Lens.Micro.Extras</a>.
(^.) :: s -> Getting a s a -> a
infixl 8 ^.

-- | <a>set</a> is a synonym for (<a>.~</a>).
--   
--   Setting the 1st component of a pair:
--   
--   <pre>
--   <a>set</a> <a>_1</a> :: x -&gt; (a, b) -&gt; (x, b)
--   <a>set</a> <a>_1</a> = \x t -&gt; (x, snd t)
--   </pre>
--   
--   Using it to rewrite (<a>&lt;$</a>):
--   
--   <pre>
--   <a>set</a> <a>mapped</a> :: <a>Functor</a> f =&gt; a -&gt; f b -&gt; f a
--   <a>set</a> <a>mapped</a> = (<a>&lt;$</a>)
--   </pre>
set :: ASetter s t a b -> b -> s -> t

-- | <a>over</a> is a synonym for (<a>%~</a>).
--   
--   Getting <a>fmap</a> in a roundabout way:
--   
--   <pre>
--   <a>over</a> <a>mapped</a> :: <a>Functor</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   <a>over</a> <a>mapped</a> = <a>fmap</a>
--   </pre>
--   
--   Applying a function to both components of a pair:
--   
--   <pre>
--   <a>over</a> <a>both</a> :: (a -&gt; b) -&gt; (a, a) -&gt; (b, b)
--   <a>over</a> <a>both</a> = \f t -&gt; (f (fst t), f (snd t))
--   </pre>
--   
--   Using <tt><a>over</a> <a>_2</a></tt> as a replacement for
--   <a>second</a>:
--   
--   <pre>
--   &gt;&gt;&gt; over _2 show (10,20)
--   (10,"20")
--   </pre>
over :: ASetter s t a b -> (a -> b) -> s -> t

-- | <a>sets</a> creates an <a>ASetter</a> from an ordinary function. (The
--   only thing it does is wrapping and unwrapping <a>Identity</a>.)
sets :: ((a -> b) -> s -> t) -> ASetter s t a b

-- | <tt>ASetter s t a b</tt> is something that turns a function modifying
--   a value into a function modifying a <i>structure</i>. If you ignore
--   <a>Identity</a> (as <tt>Identity a</tt> is the same thing as
--   <tt>a</tt>), the type is:
--   
--   <pre>
--   type ASetter s t a b = (a -&gt; b) -&gt; s -&gt; t
--   </pre>
--   
--   The reason <a>Identity</a> is used here is for <a>ASetter</a> to be
--   composable with other types, such as <a>Lens</a>.
--   
--   Technically, if you're writing a library, you shouldn't use this type
--   for setters you are exporting from your library; the right type to use
--   is <tt><a>Setter</a></tt>, but it is not provided by this package
--   (because then it'd have to depend on <a>distributive</a>). It's
--   completely alright, however, to export functions which take an
--   <a>ASetter</a> as an argument.
type ASetter s t a b = a -> Identity b -> s -> Identity t

-- | This is a type alias for monomorphic setters which don't change the
--   type of the container (or of the value inside). It's useful more often
--   than the same type in lens, because we can't provide real setters and
--   so it does the job of both <tt><a>ASetter'</a></tt> and
--   <tt><a>Setter'</a></tt>.
type ASetter' s a = ASetter s s a a

-- | A <tt>SimpleGetter s a</tt> extracts <tt>a</tt> from <tt>s</tt>; so,
--   it's the same thing as <tt>(s -&gt; a)</tt>, but you can use it in
--   lens chains because its type looks like this:
--   
--   <pre>
--   type SimpleGetter s a =
--     forall r. (a -&gt; Const r a) -&gt; s -&gt; Const r s
--   </pre>
--   
--   Since <tt>Const r</tt> is a functor, <a>SimpleGetter</a> has the same
--   shape as other lens types and can be composed with them. To get <tt>(s
--   -&gt; a)</tt> out of a <a>SimpleGetter</a>, choose <tt>r ~ a</tt> and
--   feed <tt>Const :: a -&gt; Const a a</tt> to the getter:
--   
--   <pre>
--   -- the actual signature is more permissive:
--   -- <a>view</a> :: <a>Getting</a> a s a -&gt; s -&gt; a
--   <a>view</a> :: <a>SimpleGetter</a> s a -&gt; s -&gt; a
--   <a>view</a> getter = <a>getConst</a> . getter <a>Const</a>
--   </pre>
--   
--   The actual <tt><a>Getter</a></tt> from lens is more general:
--   
--   <pre>
--   type Getter s a =
--     forall f. (Contravariant f, Functor f) =&gt; (a -&gt; f a) -&gt; s -&gt; f s
--   </pre>
--   
--   I'm not currently aware of any functions that take lens's
--   <tt>Getter</tt> but won't accept <a>SimpleGetter</a>, but you should
--   try to avoid exporting <a>SimpleGetter</a>s anyway to minimise
--   confusion. Alternatively, look at <a>microlens-contra</a>, which
--   provides a fully lens-compatible <tt>Getter</tt>.
--   
--   Lens users: you can convert a <a>SimpleGetter</a> to <tt>Getter</tt>
--   by applying <tt>to . view</tt> to it.
type SimpleGetter s a = forall r. () => Getting r s a

-- | Functions that operate on getters and folds – such as (<a>^.</a>),
--   (<a>^..</a>), (<a>^?</a>) – use <tt>Getter r s a</tt> (with different
--   values of <tt>r</tt>) to describe what kind of result they need. For
--   instance, (<a>^.</a>) needs the getter to be able to return a single
--   value, and so it accepts a getter of type <tt>Getting a s a</tt>.
--   (<a>^..</a>) wants the getter to gather values together, so it uses
--   <tt>Getting (Endo [a]) s a</tt> (it could've used <tt>Getting [a] s
--   a</tt> instead, but it's faster with <a>Endo</a>). The choice of
--   <tt>r</tt> depends on what you want to do with elements you're
--   extracting from <tt>s</tt>.
type Getting r s a = a -> Const r a -> s -> Const r s

-- | <tt>Lens s t a b</tt> is the lowest common denominator of a setter and
--   a getter, something that has the power of both; it has a
--   <a>Functor</a> constraint, and since both <a>Const</a> and
--   <a>Identity</a> are functors, it can be used whenever a getter or a
--   setter is needed.
--   
--   <ul>
--   <li><tt>a</tt> is the type of the value inside of structure</li>
--   <li><tt>b</tt> is the type of the replaced value</li>
--   <li><tt>s</tt> is the type of the whole structure</li>
--   <li><tt>t</tt> is the type of the structure after replacing <tt>a</tt>
--   in it with <tt>b</tt></li>
--   </ul>
type Lens s t a b = forall (f :: Type -> Type). Functor f => a -> f b -> s -> f t

-- | This is a type alias for monomorphic lenses which don't change the
--   type of the container (or of the value inside).
type Lens' s a = Lens s s a a

-- | Retrieves a function of the current environment.
asks :: MonadReader r m => (r -> a) -> m a

-- | Runs a <tt>Reader</tt> and extracts the final value from it. (The
--   inverse of <a>reader</a>.)
runReader :: Reader r a -> r -> a

-- | Lifted <a>newChan</a>.
newChan :: MonadIO m => m (Chan a)

-- | Lifted <a>writeChan</a>.
writeChan :: MonadIO m => Chan a -> a -> m ()

-- | Lifted <a>readChan</a>.
readChan :: MonadIO m => Chan a -> m a

-- | Lifted <a>dupChan</a>.
dupChan :: MonadIO m => Chan a -> m (Chan a)

-- | Lifted <a>getChanContents</a>.
getChanContents :: MonadIO m => Chan a -> m [a]

-- | Lifted <a>writeList2Chan</a>.
writeList2Chan :: MonadIO m => Chan a -> [a] -> m ()

-- | Exception type thrown by <a>throwString</a>.
--   
--   Note that the second field of the data constructor depends on GHC/base
--   version. For base 4.9 and GHC 8.0 and later, the second field is a
--   call stack. Previous versions of GHC and base do not support call
--   stacks, and the field is simply unit (provided to make pattern
--   matching across GHC versions easier).
data StringException
StringException :: String -> CallStack -> StringException

-- | Wrap up a synchronous exception to be treated as an asynchronous
--   exception.
--   
--   This is intended to be created via <a>toAsyncException</a>.
data AsyncExceptionWrapper
AsyncExceptionWrapper :: e -> AsyncExceptionWrapper

-- | Wrap up an asynchronous exception to be treated as a synchronous
--   exception.
--   
--   This is intended to be created via <a>toSyncException</a>.
data SyncExceptionWrapper
SyncExceptionWrapper :: e -> SyncExceptionWrapper

-- | Generalized version of <a>Handler</a>.
data Handler (m :: Type -> Type) a
Handler :: (e -> m a) -> Handler (m :: Type -> Type) a

-- | Unlifted <a>catch</a>, but will not catch asynchronous exceptions.
catch :: (MonadUnliftIO m, Exception e) => m a -> (e -> m a) -> m a

-- | <a>catch</a> specialized to only catching <a>IOException</a>s.
catchIO :: MonadUnliftIO m => m a -> (IOException -> m a) -> m a

-- | <a>catch</a> specialized to catch all synchronous exception.
catchAny :: MonadUnliftIO m => m a -> (SomeException -> m a) -> m a

-- | Same as <a>catch</a>, but fully force evaluation of the result value
--   to find all impure exceptions.
catchDeep :: (MonadUnliftIO m, Exception e, NFData a) => m a -> (e -> m a) -> m a

-- | <a>catchDeep</a> specialized to catch all synchronous exception.
catchAnyDeep :: (NFData a, MonadUnliftIO m) => m a -> (SomeException -> m a) -> m a

-- | <a>catchJust</a> is like <a>catch</a> but it takes an extra argument
--   which is an exception predicate, a function which selects which type
--   of exceptions we're interested in.
catchJust :: (MonadUnliftIO m, Exception e) => (e -> Maybe b) -> m a -> (b -> m a) -> m a

-- | Flipped version of <a>catch</a>.
handle :: (MonadUnliftIO m, Exception e) => (e -> m a) -> m a -> m a

-- | <a>handle</a> specialized to only catching <a>IOException</a>s.
handleIO :: MonadUnliftIO m => (IOException -> m a) -> m a -> m a

-- | Flipped version of <a>catchAny</a>.
handleAny :: MonadUnliftIO m => (SomeException -> m a) -> m a -> m a

-- | Flipped version of <a>catchDeep</a>.
handleDeep :: (MonadUnliftIO m, Exception e, NFData a) => (e -> m a) -> m a -> m a

-- | Flipped version of <a>catchAnyDeep</a>.
handleAnyDeep :: (MonadUnliftIO m, NFData a) => (SomeException -> m a) -> m a -> m a

-- | Flipped <a>catchJust</a>.
handleJust :: (MonadUnliftIO m, Exception e) => (e -> Maybe b) -> (b -> m a) -> m a -> m a

-- | Unlifted <a>try</a>, but will not catch asynchronous exceptions.
try :: (MonadUnliftIO m, Exception e) => m a -> m (Either e a)

-- | <a>try</a> specialized to only catching <a>IOException</a>s.
tryIO :: MonadUnliftIO m => m a -> m (Either IOException a)

-- | <a>try</a> specialized to catch all synchronous exceptions.
tryAny :: MonadUnliftIO m => m a -> m (Either SomeException a)

-- | Same as <a>try</a>, but fully force evaluation of the result value to
--   find all impure exceptions.
tryDeep :: (MonadUnliftIO m, Exception e, NFData a) => m a -> m (Either e a)

-- | <a>tryDeep</a> specialized to catch all synchronous exceptions.
tryAnyDeep :: (MonadUnliftIO m, NFData a) => m a -> m (Either SomeException a)

-- | A variant of <a>try</a> that takes an exception predicate to select
--   which exceptions are caught.
tryJust :: (MonadUnliftIO m, Exception e) => (e -> Maybe b) -> m a -> m (Either b a)

-- | Evaluate the value to WHNF and catch any synchronous exceptions.
--   
--   The expression may still have bottom values within it; you may instead
--   want to use <a>pureTryDeep</a>.
pureTry :: a -> Either SomeException a

-- | Evaluate the value to NF and catch any synchronous exceptions.
pureTryDeep :: NFData a => a -> Either SomeException a

-- | Same as upstream <a>catches</a>, but will not catch asynchronous
--   exceptions.
catches :: MonadUnliftIO m => m a -> [Handler m a] -> m a

-- | Same as <a>catches</a>, but fully force evaluation of the result value
--   to find all impure exceptions.
catchesDeep :: (MonadUnliftIO m, NFData a) => m a -> [Handler m a] -> m a

-- | Lifted version of <a>evaluate</a>.
evaluate :: MonadIO m => a -> m a

-- | Deeply evaluate a value using <a>evaluate</a> and <a>NFData</a>.
evaluateDeep :: (MonadIO m, NFData a) => a -> m a

-- | Async safe version of <a>bracket</a>.
bracket :: MonadUnliftIO m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Async safe version of <a>bracket_</a>.
bracket_ :: MonadUnliftIO m => m a -> m b -> m c -> m c

-- | Async safe version of <a>bracketOnError</a>.
bracketOnError :: MonadUnliftIO m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | A variant of <a>bracketOnError</a> where the return value from the
--   first computation is not required.
bracketOnError_ :: MonadUnliftIO m => m a -> m b -> m c -> m c

-- | Async safe version of <a>finally</a>.
finally :: MonadUnliftIO m => m a -> m b -> m a

-- | Like <a>onException</a>, but provides the handler the thrown
--   exception.
withException :: (MonadUnliftIO m, Exception e) => m a -> (e -> m b) -> m a

-- | Async safe version of <a>onException</a>.
onException :: MonadUnliftIO m => m a -> m b -> m a

-- | Synchronously throw the given exception.
throwIO :: (MonadIO m, Exception e) => e -> m a

-- | Convert an exception into a synchronous exception.
--   
--   For synchronous exceptions, this is the same as <a>toException</a>.
--   For asynchronous exceptions, this will wrap up the exception with
--   <a>SyncExceptionWrapper</a>.
toSyncException :: Exception e => e -> SomeException

-- | Convert an exception into an asynchronous exception.
--   
--   For asynchronous exceptions, this is the same as <a>toException</a>.
--   For synchronous exceptions, this will wrap up the exception with
--   <a>AsyncExceptionWrapper</a>.
toAsyncException :: Exception e => e -> SomeException

-- | Check if the given exception is synchronous.
isSyncException :: Exception e => e -> Bool

-- | Check if the given exception is asynchronous.
isAsyncException :: Exception e => e -> Bool

-- | Unlifted version of <a>mask</a>.
mask :: MonadUnliftIO m => ((forall a. () => m a -> m a) -> m b) -> m b

-- | Unlifted version of <a>uninterruptibleMask</a>.
uninterruptibleMask :: MonadUnliftIO m => ((forall a. () => m a -> m a) -> m b) -> m b

-- | Unlifted version of <a>mask_</a>.
mask_ :: MonadUnliftIO m => m a -> m a

-- | Unlifted version of <a>uninterruptibleMask_</a>.
uninterruptibleMask_ :: MonadUnliftIO m => m a -> m a

-- | A convenience function for throwing a user error. This is useful for
--   cases where it would be too high a burden to define your own exception
--   type.
--   
--   This throws an exception of type <a>StringException</a>. When GHC
--   supports it (base 4.9 and GHC 8.0 and onward), it includes a call
--   stack.
throwString :: (MonadIO m, HasCallStack) => String -> m a

-- | Smart constructor for a <a>StringException</a> that deals with the
--   call stack.
stringException :: HasCallStack => String -> StringException

-- | Throw an asynchronous exception to another thread.
--   
--   Synchronously typed exceptions will be wrapped into an
--   <a>AsyncExceptionWrapper</a>, see
--   <a>https://github.com/fpco/safe-exceptions#determining-sync-vs-async</a>.
--   
--   It's usually a better idea to use the <a>UnliftIO.Async</a> module,
--   see <a>https://github.com/fpco/safe-exceptions#quickstart</a>.
throwTo :: (Exception e, MonadIO m) => ThreadId -> e -> m ()

-- | Generate a pure value which, when forced, will synchronously throw the
--   given exception.
--   
--   Generally it's better to avoid using this function and instead use
--   <a>throwIO</a>, see
--   <a>https://github.com/fpco/safe-exceptions#quickstart</a>.
impureThrow :: Exception e => e -> a

-- | Unwrap an <a>Either</a> value, throwing its <a>Left</a> value as a
--   runtime exception via <a>throwIO</a> if present.
fromEither :: (Exception e, MonadIO m) => Either e a -> m a

-- | Same as <a>fromEither</a>, but works on an <a>IO</a>-wrapped
--   <a>Either</a>.
fromEitherIO :: (Exception e, MonadIO m) => IO (Either e a) -> m a

-- | Same as <a>fromEither</a>, but works on an <tt>m</tt>-wrapped
--   <a>Either</a>.
fromEitherM :: (Exception e, MonadIO m) => m (Either e a) -> m a

-- | Unlifted version of <a>withFile</a>.
withFile :: MonadUnliftIO m => FilePath -> IOMode -> (Handle -> m a) -> m a

-- | Lifted version of <a>hClose</a>
hClose :: MonadIO m => Handle -> m ()

-- | Lifted version of <a>hFlush</a>
hFlush :: MonadIO m => Handle -> m ()

-- | Lifted version of <a>hFileSize</a>
hFileSize :: MonadIO m => Handle -> m Integer

-- | Lifted version of <a>hSetFileSize</a>
hSetFileSize :: MonadIO m => Handle -> Integer -> m ()

-- | Lifted version of <a>hIsEOF</a>
hIsEOF :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hSetBuffering</a>
hSetBuffering :: MonadIO m => Handle -> BufferMode -> m ()

-- | Lifted version of <a>hGetBuffering</a>
hGetBuffering :: MonadIO m => Handle -> m BufferMode

-- | Lifted version of <a>hSeek</a>
hSeek :: MonadIO m => Handle -> SeekMode -> Integer -> m ()

-- | Lifted version of <a>hTell</a>
hTell :: MonadIO m => Handle -> m Integer

-- | Lifted version of <a>hIsOpen</a>
hIsOpen :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hIsClosed</a>
hIsClosed :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hIsReadable</a>
hIsReadable :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hIsWritable</a>
hIsWritable :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hIsSeekable</a>
hIsSeekable :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hIsTerminalDevice</a>
hIsTerminalDevice :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hSetEcho</a>
hSetEcho :: MonadIO m => Handle -> Bool -> m ()

-- | Lifted version of <a>hGetEcho</a>
hGetEcho :: MonadIO m => Handle -> m Bool

-- | Lifted version of <a>hWaitForInput</a>
hWaitForInput :: MonadIO m => Handle -> Int -> m Bool

-- | Lifted version of <a>hReady</a>
hReady :: MonadIO m => Handle -> m Bool

-- | Get the number of seconds which have passed since an arbitrary
--   starting time, useful for calculating runtime in a program.
getMonotonicTime :: MonadIO m => m Double

-- | Lifted <a>newIORef</a>.
newIORef :: MonadIO m => a -> m (IORef a)

-- | Lifted <a>readIORef</a>.
readIORef :: MonadIO m => IORef a -> m a

-- | Lifted <a>writeIORef</a>.
writeIORef :: MonadIO m => IORef a -> a -> m ()

-- | Lifted <a>modifyIORef</a>.
modifyIORef :: MonadIO m => IORef a -> (a -> a) -> m ()

-- | Lifted <a>modifyIORef'</a>.
modifyIORef' :: MonadIO m => IORef a -> (a -> a) -> m ()

-- | Lifted <a>atomicModifyIORef</a>.
atomicModifyIORef :: MonadIO m => IORef a -> (a -> (a, b)) -> m b

-- | Lifted <a>atomicModifyIORef'</a>.
atomicModifyIORef' :: MonadIO m => IORef a -> (a -> (a, b)) -> m b

-- | Lifted <a>atomicWriteIORef</a>.
atomicWriteIORef :: MonadIO m => IORef a -> a -> m ()

-- | Unlifted <a>mkWeakIORef</a>.
mkWeakIORef :: MonadUnliftIO m => IORef a -> m () -> m (Weak (IORef a))

-- | Things that can go wrong in the structure of a <a>Conc</a>. These are
--   <i>programmer errors</i>.
data ConcException
EmptyWithNoAlternative :: ConcException

-- | A more efficient alternative to <a>Concurrently</a>, which reduces the
--   number of threads that need to be forked. For more information, see
--   <tt>FIXME link to blog post</tt>. This is provided as a separate type
--   to <tt>Concurrently</tt> as it has a slightly different API.
--   
--   Use the <a>conc</a> function to construct values of type <a>Conc</a>,
--   and <a>runConc</a> to execute the composed actions. You can use the
--   <tt>Applicative</tt> instance to run different actions and wait for
--   all of them to complete, or the <tt>Alternative</tt> instance to wait
--   for the first thread to complete.
--   
--   In the event of a runtime exception thrown by any of the children
--   threads, or an asynchronous exception received in the parent thread,
--   all threads will be killed with an <a>AsyncCancelled</a> exception and
--   the original exception rethrown. If multiple exceptions are generated
--   by different threads, there are no guarantees on which exception will
--   end up getting rethrown.
--   
--   For many common use cases, you may prefer using helper functions in
--   this module like <a>mapConcurrently</a>.
--   
--   There are some intentional differences in behavior to
--   <tt>Concurrently</tt>:
--   
--   <ul>
--   <li>Children threads are always launched in an unmasked state, not the
--   inherited state of the parent thread.</li>
--   </ul>
--   
--   Note that it is a programmer error to use the <tt>Alternative</tt>
--   instance in such a way that there are no alternatives to an empty,
--   e.g. <tt>runConc (empty <a>|</a> empty)</tt>. In such a case, a
--   <a>ConcException</a> will be thrown. If there was an
--   <tt>Alternative</tt> in the standard libraries without <tt>empty</tt>,
--   this library would use it instead.
data Conc (m :: Type -> Type) a

-- | Unlifted <a>Concurrently</a>.
newtype Concurrently (m :: Type -> Type) a
Concurrently :: m a -> Concurrently (m :: Type -> Type) a
[runConcurrently] :: Concurrently (m :: Type -> Type) a -> m a

-- | Unlifted <a>async</a>.
async :: MonadUnliftIO m => m a -> m (Async a)

-- | Unlifted <a>asyncBound</a>.
asyncBound :: MonadUnliftIO m => m a -> m (Async a)

-- | Unlifted <a>asyncOn</a>.
asyncOn :: MonadUnliftIO m => Int -> m a -> m (Async a)

-- | Unlifted <a>asyncWithUnmask</a>.
asyncWithUnmask :: MonadUnliftIO m => ((forall b. () => m b -> m b) -> m a) -> m (Async a)

-- | Unlifted <a>asyncOnWithUnmask</a>.
asyncOnWithUnmask :: MonadUnliftIO m => Int -> ((forall b. () => m b -> m b) -> m a) -> m (Async a)

-- | Unlifted <a>withAsync</a>.
withAsync :: MonadUnliftIO m => m a -> (Async a -> m b) -> m b

-- | Unlifted <a>withAsyncBound</a>.
withAsyncBound :: MonadUnliftIO m => m a -> (Async a -> m b) -> m b

-- | Unlifted <a>withAsyncOn</a>.
withAsyncOn :: MonadUnliftIO m => Int -> m a -> (Async a -> m b) -> m b

-- | Unlifted <a>withAsyncWithUnmask</a>.
withAsyncWithUnmask :: MonadUnliftIO m => ((forall c. () => m c -> m c) -> m a) -> (Async a -> m b) -> m b

-- | Unlifted <a>withAsyncOnWithMask</a>.
withAsyncOnWithUnmask :: MonadUnliftIO m => Int -> ((forall c. () => m c -> m c) -> m a) -> (Async a -> m b) -> m b

-- | Lifted <a>wait</a>.
wait :: MonadIO m => Async a -> m a

-- | Lifted <a>poll</a>.
poll :: MonadIO m => Async a -> m (Maybe (Either SomeException a))

-- | Lifted <a>waitCatch</a>.
waitCatch :: MonadIO m => Async a -> m (Either SomeException a)

-- | Lifted <a>cancel</a>.
cancel :: MonadIO m => Async a -> m ()

-- | Lifted <a>uninterruptibleCancel</a>.
uninterruptibleCancel :: MonadIO m => Async a -> m ()

-- | Lifted <a>cancelWith</a>. Additionally uses <a>toAsyncException</a> to
--   ensure async exception safety.
cancelWith :: (Exception e, MonadIO m) => Async a -> e -> m ()

-- | Lifted <a>waitAny</a>.
waitAny :: MonadIO m => [Async a] -> m (Async a, a)

-- | Lifted <a>waitAnyCatch</a>.
waitAnyCatch :: MonadIO m => [Async a] -> m (Async a, Either SomeException a)

-- | Lifted <a>waitAnyCancel</a>.
waitAnyCancel :: MonadIO m => [Async a] -> m (Async a, a)

-- | Lifted <a>waitAnyCatchCancel</a>.
waitAnyCatchCancel :: MonadIO m => [Async a] -> m (Async a, Either SomeException a)

-- | Lifted <a>waitEither</a>.
waitEither :: MonadIO m => Async a -> Async b -> m (Either a b)

-- | Lifted <a>waitEitherCatch</a>.
waitEitherCatch :: MonadIO m => Async a -> Async b -> m (Either (Either SomeException a) (Either SomeException b))

-- | Lifted <a>waitEitherCancel</a>.
waitEitherCancel :: MonadIO m => Async a -> Async b -> m (Either a b)

-- | Lifted <a>waitEitherCatchCancel</a>.
waitEitherCatchCancel :: MonadIO m => Async a -> Async b -> m (Either (Either SomeException a) (Either SomeException b))

-- | Lifted <a>waitEither_</a>.
waitEither_ :: MonadIO m => Async a -> Async b -> m ()

-- | Lifted <a>waitBoth</a>.
waitBoth :: MonadIO m => Async a -> Async b -> m (a, b)

-- | Lifted <a>link</a>.
link :: MonadIO m => Async a -> m ()

-- | Lifted <a>link2</a>.
link2 :: MonadIO m => Async a -> Async b -> m ()

-- | Unlifted <a>race</a>.
race :: MonadUnliftIO m => m a -> m b -> m (Either a b)

-- | Unlifted <a>race_</a>.
race_ :: MonadUnliftIO m => m a -> m b -> m ()

-- | Unlifted <a>concurrently</a>.
concurrently :: MonadUnliftIO m => m a -> m b -> m (a, b)

-- | Unlifted <a>concurrently_</a>.
concurrently_ :: MonadUnliftIO m => m a -> m b -> m ()

-- | Similar to <a>mapConcurrently</a> but with arguments flipped
forConcurrently :: (MonadUnliftIO m, Traversable t) => t a -> (a -> m b) -> m (t b)

-- | Similar to <a>mapConcurrently_</a> but with arguments flipped
forConcurrently_ :: (MonadUnliftIO m, Foldable f) => f a -> (a -> m b) -> m ()

-- | Unlifted <a>replicateConcurrently</a>.
replicateConcurrently :: MonadUnliftIO m => Int -> m b -> m [b]

-- | Unlifted <a>replicateConcurrently_</a>.
replicateConcurrently_ :: (Applicative m, MonadUnliftIO m) => Int -> m a -> m ()

-- | Executes a <a>Traversable</a> container of items concurrently, it uses
--   the <a>Flat</a> type internally.
mapConcurrently :: (MonadUnliftIO m, Traversable t) => (a -> m b) -> t a -> m (t b)

-- | Executes a <a>Traversable</a> container of items concurrently, it uses
--   the <a>Flat</a> type internally. This function ignores the results.
mapConcurrently_ :: (MonadUnliftIO m, Foldable f) => (a -> m b) -> f a -> m ()

-- | Construct a value of type <a>Conc</a> from an action. Compose these
--   values using the typeclass instances (most commonly <a>Applicative</a>
--   and <a>Alternative</a>) and then run with <a>runConc</a>.
conc :: m a -> Conc m a

-- | Run a <a>Conc</a> value on multiple threads.
runConc :: MonadUnliftIO m => Conc m a -> m a

-- | Like <a>mapConcurrently</a> from async, but instead of one thread per
--   element, it does pooling from a set of threads. This is useful in
--   scenarios where resource consumption is bounded and for use cases
--   where too many concurrent tasks aren't allowed.
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   import Say
--   
--   action :: Int -&gt; IO Int
--   action n = do
--     tid &lt;- myThreadId
--     sayString $ show tid
--     threadDelay (2 * 10^6) -- 2 seconds
--     return n
--   
--   main :: IO ()
--   main = do
--     yx &lt;- pooledMapConcurrentlyN 5 (\x -&gt; action x) [1..5]
--     print yx
--   </pre>
--   
--   On executing you can see that five threads have been spawned:
--   
--   <pre>
--   $ ./pool
--   ThreadId 36
--   ThreadId 38
--   ThreadId 40
--   ThreadId 42
--   ThreadId 44
--   [1,2,3,4,5]
--   </pre>
--   
--   Let's modify the above program such that there are less threads than
--   the number of items in the list:
--   
--   <pre>
--   import Say
--   
--   action :: Int -&gt; IO Int
--   action n = do
--     tid &lt;- myThreadId
--     sayString $ show tid
--     threadDelay (2 * 10^6) -- 2 seconds
--     return n
--   
--   main :: IO ()
--   main = do
--     yx &lt;- pooledMapConcurrentlyN 3 (\x -&gt; action x) [1..5]
--     print yx
--   </pre>
--   
--   On executing you can see that only three threads are active totally:
--   
--   <pre>
--   $ ./pool
--   ThreadId 35
--   ThreadId 37
--   ThreadId 39
--   ThreadId 35
--   ThreadId 39
--   [1,2,3,4,5]
--   </pre>
pooledMapConcurrentlyN :: (MonadUnliftIO m, Traversable t) => Int -> (a -> m b) -> t a -> m (t b)

-- | Similar to <a>pooledMapConcurrentlyN</a> but with number of threads
--   set from <a>getNumCapabilities</a>. Usually this is useful for CPU
--   bound tasks.
pooledMapConcurrently :: (MonadUnliftIO m, Traversable t) => (a -> m b) -> t a -> m (t b)

-- | Similar to <a>pooledMapConcurrentlyN</a> but with flipped arguments.
pooledForConcurrentlyN :: (MonadUnliftIO m, Traversable t) => Int -> t a -> (a -> m b) -> m (t b)

-- | Similar to <a>pooledForConcurrentlyN</a> but with number of threads
--   set from <a>getNumCapabilities</a>. Usually this is useful for CPU
--   bound tasks.
pooledForConcurrently :: (MonadUnliftIO m, Traversable t) => t a -> (a -> m b) -> m (t b)

-- | Like <a>pooledMapConcurrentlyN</a> but with the return value
--   discarded.
pooledMapConcurrentlyN_ :: (MonadUnliftIO m, Foldable f) => Int -> (a -> m b) -> f a -> m ()

-- | Like <a>pooledMapConcurrently</a> but with the return value discarded.
pooledMapConcurrently_ :: (MonadUnliftIO m, Foldable f) => (a -> m b) -> f a -> m ()

-- | Like <a>pooledMapConcurrently_</a> but with flipped arguments.
pooledForConcurrently_ :: (MonadUnliftIO m, Foldable f) => f a -> (a -> m b) -> m ()

-- | Like <a>pooledMapConcurrentlyN_</a> but with flipped arguments.
pooledForConcurrentlyN_ :: (MonadUnliftIO m, Foldable t) => Int -> t a -> (a -> m b) -> m ()

-- | Pooled version of <a>replicateConcurrently</a>. Performs the action in
--   the pooled threads.
pooledReplicateConcurrentlyN :: MonadUnliftIO m => Int -> Int -> m a -> m [a]

-- | Similar to <a>pooledReplicateConcurrentlyN</a> but with number of
--   threads set from <a>getNumCapabilities</a>. Usually this is useful for
--   CPU bound tasks.
pooledReplicateConcurrently :: MonadUnliftIO m => Int -> m a -> m [a]

-- | Pooled version of <a>replicateConcurrently_</a>. Performs the action
--   in the pooled threads.
pooledReplicateConcurrentlyN_ :: MonadUnliftIO m => Int -> Int -> m a -> m ()

-- | Similar to <a>pooledReplicateConcurrently_</a> but with number of
--   threads set from <a>getNumCapabilities</a>. Usually this is useful for
--   CPU bound tasks.
pooledReplicateConcurrently_ :: MonadUnliftIO m => Int -> m a -> m ()

-- | Lifted <a>newEmptyMVar</a>.
newEmptyMVar :: MonadIO m => m (MVar a)

-- | Lifted <a>newMVar</a>.
newMVar :: MonadIO m => a -> m (MVar a)

-- | Lifted <a>takeMVar</a>.
takeMVar :: MonadIO m => MVar a -> m a

-- | Lifted <a>putMVar</a>.
putMVar :: MonadIO m => MVar a -> a -> m ()

-- | Lifted <a>readMVar</a>.
readMVar :: MonadIO m => MVar a -> m a

-- | Lifted <a>swapMVar</a>.
swapMVar :: MonadIO m => MVar a -> a -> m a

-- | Lifted <a>tryTakeMVar</a>.
tryTakeMVar :: MonadIO m => MVar a -> m (Maybe a)

-- | Lifted <a>tryPutMVar</a>.
tryPutMVar :: MonadIO m => MVar a -> a -> m Bool

-- | Lifted <a>isEmptyMVar</a>.
isEmptyMVar :: MonadIO m => MVar a -> m Bool

-- | Lifted <a>tryReadMVar</a>.
tryReadMVar :: MonadIO m => MVar a -> m (Maybe a)

-- | Unlifted <a>withMVar</a>.
withMVar :: MonadUnliftIO m => MVar a -> (a -> m b) -> m b

-- | Unlifted <a>withMVarMasked</a>.
withMVarMasked :: MonadUnliftIO m => MVar a -> (a -> m b) -> m b

-- | Unlifted <a>modifyMVar_</a>.
modifyMVar_ :: MonadUnliftIO m => MVar a -> (a -> m a) -> m ()

-- | Unlifted <a>modifyMVar</a>.
modifyMVar :: MonadUnliftIO m => MVar a -> (a -> m (a, b)) -> m b

-- | Unlifted <a>modifyMVarMasked_</a>.
modifyMVarMasked_ :: MonadUnliftIO m => MVar a -> (a -> m a) -> m ()

-- | Unlifted <a>modifyMVarMasked</a>.
modifyMVarMasked :: MonadUnliftIO m => MVar a -> (a -> m (a, b)) -> m b

-- | Unlifted <a>mkWeakMVar</a>.
mkWeakMVar :: MonadUnliftIO m => MVar a -> m () -> m (Weak (MVar a))

-- | A "run once" value, with results saved. Extract the value with
--   <a>runMemoized</a>. For single-threaded usage, you can use
--   <a>memoizeRef</a> to create a value. If you need guarantees that only
--   one thread will run the action at a time, use <a>memoizeMVar</a>.
--   
--   Note that this type provides a <a>Show</a> instance for convenience,
--   but not useful information can be provided.
data Memoized a

-- | Extract a value from a <a>Memoized</a>, running an action if no cached
--   value is available.
runMemoized :: MonadIO m => Memoized a -> m a

-- | Create a new <a>Memoized</a> value using an <a>IORef</a> under the
--   surface. Note that the action may be run in multiple threads
--   simultaneously, so this may not be thread safe (depending on the
--   underlying action). Consider using <a>memoizeMVar</a>.
memoizeRef :: MonadUnliftIO m => m a -> m (Memoized a)

-- | Same as <a>memoizeRef</a>, but uses an <a>MVar</a> to ensure that an
--   action is only run once, even in a multithreaded application.
memoizeMVar :: MonadUnliftIO m => m a -> m (Memoized a)

-- | Lifted version of <a>atomically</a>
atomically :: MonadIO m => STM a -> m a

-- | Renamed <a>retry</a> for unqualified export
retrySTM :: STM a

-- | Renamed <a>check</a> for unqualified export
checkSTM :: Bool -> STM ()

-- | Lifted version of <a>newTVarIO</a>
newTVarIO :: MonadIO m => a -> m (TVar a)

-- | Lifted version of <a>readTVarIO</a>
readTVarIO :: MonadIO m => TVar a -> m a

-- | Lifted version of <a>registerDelay</a>
registerDelay :: MonadIO m => Int -> m (TVar Bool)

-- | Lifted version of <a>mkWeakTVar</a>
mkWeakTVar :: MonadUnliftIO m => TVar a -> m () -> m (Weak (TVar a))

-- | Lifted version of <a>newTMVarIO</a>
newTMVarIO :: MonadIO m => a -> m (TMVar a)

-- | Lifted version of <a>newEmptyTMVarIO</a>
newEmptyTMVarIO :: MonadIO m => m (TMVar a)

-- | Lifted version of <a>mkWeakTMVar</a>
mkWeakTMVar :: MonadUnliftIO m => TMVar a -> m () -> m (Weak (TMVar a))

-- | Lifted version of <a>newTChanIO</a>
newTChanIO :: MonadIO m => m (TChan a)

-- | Lifted version of <a>newBroadcastTChanIO</a>
newBroadcastTChanIO :: MonadIO m => m (TChan a)

-- | Lifted version of <a>newTQueueIO</a>
newTQueueIO :: MonadIO m => m (TQueue a)

-- | Lifted version of <a>newTBQueueIO</a>
newTBQueueIO :: MonadIO m => Natural -> m (TBQueue a)

-- | Create and use a temporary file in the system standard temporary
--   directory.
--   
--   Behaves exactly the same as <a>withTempFile</a>, except that the
--   parent temporary directory will be that returned by
--   <a>getCanonicalTemporaryDirectory</a>.
withSystemTempFile :: MonadUnliftIO m => String -> (FilePath -> Handle -> m a) -> m a

-- | Create and use a temporary directory in the system standard temporary
--   directory.
--   
--   Behaves exactly the same as <a>withTempDirectory</a>, except that the
--   parent temporary directory will be that returned by
--   <a>getCanonicalTemporaryDirectory</a>.
withSystemTempDirectory :: MonadUnliftIO m => String -> (FilePath -> m a) -> m a

-- | Use a temporary filename that doesn't already exist.
--   
--   Creates a new temporary file inside the given directory, making use of
--   the template. The temp file is deleted after use. For example:
--   
--   <pre>
--   withTempFile "src" "sdist." $ \tmpFile hFile -&gt; do ...
--   </pre>
--   
--   The <tt>tmpFile</tt> will be file in the given directory, e.g.
--   <tt>src/sdist.342</tt>.
withTempFile :: MonadUnliftIO m => FilePath -> String -> (FilePath -> Handle -> m a) -> m a

-- | Create and use a temporary directory.
--   
--   Creates a new temporary directory inside the given directory, making
--   use of the template. The temp directory is deleted after use. For
--   example:
--   
--   <pre>
--   withTempDirectory "src" "sdist." $ \tmpDir -&gt; do ...
--   </pre>
--   
--   The <tt>tmpDir</tt> will be a new subdirectory of the given directory,
--   e.g. <tt>src/sdist.342</tt>.
withTempDirectory :: MonadUnliftIO m => FilePath -> String -> (FilePath -> m a) -> m a

-- | Unlifted <a>timeout</a>.
timeout :: MonadUnliftIO m => Int -> m a -> m (Maybe a)

-- | A helper function for implementing <tt>MonadUnliftIO</tt> instances.
--   Useful for the common case where you want to simply delegate to the
--   underlying transformer.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   newtype AppT m a = AppT { unAppT :: ReaderT Int (ResourceT m) a }
--     deriving (Functor, Applicative, Monad, MonadIO)
--     -- Unfortunately, deriving MonadUnliftIO does not work.
--   
--   instance MonadUnliftIO m =&gt; MonadUnliftIO (AppT m) where
--     withRunInIO = wrappedWithRunInIO AppT unAppT
--   </pre>
wrappedWithRunInIO :: MonadUnliftIO n => (n b -> m b) -> (forall a. () => m a -> n a) -> ((forall a. () => m a -> IO a) -> IO b) -> m b

-- | Convert an action in <tt>m</tt> to an action in <tt>IO</tt>.
toIO :: MonadUnliftIO m => m a -> m (IO a)

-- | Convenience function for capturing the monadic context and running an
--   <a>IO</a> action. The <a>UnliftIO</a> newtype wrapper is rarely
--   needed, so prefer <a>withRunInIO</a> to this function.
withUnliftIO :: MonadUnliftIO m => (UnliftIO m -> IO a) -> m a

-- | Same as <a>askUnliftIO</a>, but returns a monomorphic function instead
--   of a polymorphic newtype wrapper. If you only need to apply the
--   transformation on one concrete type, this function can be more
--   convenient.
askRunInIO :: MonadUnliftIO m => m (m a -> IO a)

-- | The ability to run any monadic action <tt>m a</tt> as <tt>IO a</tt>.
--   
--   This is more precisely a natural transformation. We need to new
--   datatype (instead of simply using a <tt>forall</tt>) due to lack of
--   support in GHC for impredicative types.
newtype UnliftIO (m :: Type -> Type)
UnliftIO :: (forall a. () => m a -> IO a) -> UnliftIO (m :: Type -> Type)
[unliftIO] :: UnliftIO (m :: Type -> Type) -> forall a. () => m a -> IO a

-- | <a>TBQueue</a> is an abstract type representing a bounded FIFO
--   channel.
data TBQueue a

-- | Builds and returns a new instance of <a>TBQueue</a>.
newTBQueue :: Natural -> STM (TBQueue a)

-- | Write a value to a <a>TBQueue</a>; blocks if the queue is full.
writeTBQueue :: TBQueue a -> a -> STM ()

-- | Read the next value from the <a>TBQueue</a>.
readTBQueue :: TBQueue a -> STM a

-- | A version of <a>readTBQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryReadTBQueue :: TBQueue a -> STM (Maybe a)

-- | Get the next value from the <tt>TBQueue</tt> without removing it,
--   retrying if the channel is empty.
peekTBQueue :: TBQueue a -> STM a

-- | A version of <a>peekTBQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryPeekTBQueue :: TBQueue a -> STM (Maybe a)

-- | Put a data item back onto a channel, where it will be the next item
--   read. Blocks if the queue is full.
unGetTBQueue :: TBQueue a -> a -> STM ()

-- | Returns <a>True</a> if the supplied <a>TBQueue</a> is empty.
isEmptyTBQueue :: TBQueue a -> STM Bool

-- | Returns <a>True</a> if the supplied <a>TBQueue</a> is full.
isFullTBQueue :: TBQueue a -> STM Bool

-- | <a>TChan</a> is an abstract type representing an unbounded FIFO
--   channel.
data TChan a

-- | Build and return a new instance of <a>TChan</a>
newTChan :: STM (TChan a)

-- | Create a write-only <a>TChan</a>. More precisely, <a>readTChan</a>
--   will <a>retry</a> even after items have been written to the channel.
--   The only way to read a broadcast channel is to duplicate it with
--   <a>dupTChan</a>.
--   
--   Consider a server that broadcasts messages to clients:
--   
--   <pre>
--   serve :: TChan Message -&gt; Client -&gt; IO loop
--   serve broadcastChan client = do
--       myChan &lt;- dupTChan broadcastChan
--       forever $ do
--           message &lt;- readTChan myChan
--           send client message
--   </pre>
--   
--   The problem with using <a>newTChan</a> to create the broadcast channel
--   is that if it is only written to and never read, items will pile up in
--   memory. By using <a>newBroadcastTChan</a> to create the broadcast
--   channel, items can be garbage collected after clients have seen them.
newBroadcastTChan :: STM (TChan a)

-- | Write a value to a <a>TChan</a>.
writeTChan :: TChan a -> a -> STM ()

-- | Read the next value from the <a>TChan</a>.
readTChan :: TChan a -> STM a

-- | A version of <a>readTChan</a> which does not retry. Instead it returns
--   <tt>Nothing</tt> if no value is available.
tryReadTChan :: TChan a -> STM (Maybe a)

-- | Get the next value from the <tt>TChan</tt> without removing it,
--   retrying if the channel is empty.
peekTChan :: TChan a -> STM a

-- | A version of <a>peekTChan</a> which does not retry. Instead it returns
--   <tt>Nothing</tt> if no value is available.
tryPeekTChan :: TChan a -> STM (Maybe a)

-- | Duplicate a <a>TChan</a>: the duplicate channel begins empty, but data
--   written to either channel from then on will be available from both.
--   Hence this creates a kind of broadcast channel, where data written by
--   anyone is seen by everyone else.
dupTChan :: TChan a -> STM (TChan a)

-- | Put a data item back onto a channel, where it will be the next item
--   read.
unGetTChan :: TChan a -> a -> STM ()

-- | Returns <a>True</a> if the supplied <a>TChan</a> is empty.
isEmptyTChan :: TChan a -> STM Bool

-- | Clone a <a>TChan</a>: similar to dupTChan, but the cloned channel
--   starts with the same content available as the original channel.
cloneTChan :: TChan a -> STM (TChan a)

-- | A <a>TMVar</a> is a synchronising variable, used for communication
--   between concurrent threads. It can be thought of as a box, which may
--   be empty or full.
data TMVar a

-- | Create a <a>TMVar</a> which contains the supplied value.
newTMVar :: a -> STM (TMVar a)

-- | Create a <a>TMVar</a> which is initially empty.
newEmptyTMVar :: STM (TMVar a)

-- | Return the contents of the <a>TMVar</a>. If the <a>TMVar</a> is
--   currently empty, the transaction will <a>retry</a>. After a
--   <a>takeTMVar</a>, the <a>TMVar</a> is left empty.
takeTMVar :: TMVar a -> STM a

-- | A version of <a>takeTMVar</a> that does not <a>retry</a>. The
--   <a>tryTakeTMVar</a> function returns <a>Nothing</a> if the
--   <a>TMVar</a> was empty, or <tt><a>Just</a> a</tt> if the <a>TMVar</a>
--   was full with contents <tt>a</tt>. After <a>tryTakeTMVar</a>, the
--   <a>TMVar</a> is left empty.
tryTakeTMVar :: TMVar a -> STM (Maybe a)

-- | Put a value into a <a>TMVar</a>. If the <a>TMVar</a> is currently
--   full, <a>putTMVar</a> will <a>retry</a>.
putTMVar :: TMVar a -> a -> STM ()

-- | A version of <a>putTMVar</a> that does not <a>retry</a>. The
--   <a>tryPutTMVar</a> function attempts to put the value <tt>a</tt> into
--   the <a>TMVar</a>, returning <a>True</a> if it was successful, or
--   <a>False</a> otherwise.
tryPutTMVar :: TMVar a -> a -> STM Bool

-- | This is a combination of <a>takeTMVar</a> and <a>putTMVar</a>; ie. it
--   takes the value from the <a>TMVar</a>, puts it back, and also returns
--   it.
readTMVar :: TMVar a -> STM a

-- | A version of <a>readTMVar</a> which does not retry. Instead it returns
--   <tt>Nothing</tt> if no value is available.
tryReadTMVar :: TMVar a -> STM (Maybe a)

-- | Swap the contents of a <a>TMVar</a> for a new value.
swapTMVar :: TMVar a -> a -> STM a

-- | Check whether a given <a>TMVar</a> is empty.
isEmptyTMVar :: TMVar a -> STM Bool

-- | <a>TQueue</a> is an abstract type representing an unbounded FIFO
--   channel.
data TQueue a

-- | Build and returns a new instance of <a>TQueue</a>
newTQueue :: STM (TQueue a)

-- | Write a value to a <a>TQueue</a>.
writeTQueue :: TQueue a -> a -> STM ()

-- | Read the next value from the <a>TQueue</a>.
readTQueue :: TQueue a -> STM a

-- | A version of <a>readTQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryReadTQueue :: TQueue a -> STM (Maybe a)

-- | Get the next value from the <tt>TQueue</tt> without removing it,
--   retrying if the channel is empty.
peekTQueue :: TQueue a -> STM a

-- | A version of <a>peekTQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryPeekTQueue :: TQueue a -> STM (Maybe a)

-- | Put a data item back onto a channel, where it will be the next item
--   read.
unGetTQueue :: TQueue a -> a -> STM ()

-- | Returns <a>True</a> if the supplied <a>TQueue</a> is empty.
isEmptyTQueue :: TQueue a -> STM Bool

-- | Mutate the contents of a <a>TVar</a>. <i>N.B.</i>, this version is
--   non-strict.
modifyTVar :: TVar a -> (a -> a) -> STM ()

-- | Strict version of <a>modifyTVar</a>.
modifyTVar' :: TVar a -> (a -> a) -> STM ()

-- | Swap the contents of a <a>TVar</a> for a new value.
swapTVar :: TVar a -> a -> STM a

traceDisplayStack :: Display a => a -> b -> b

traceDisplayMarkerIO :: (Display a, MonadIO m) => a -> m ()

traceDisplayMarker :: Display a => a -> b -> b

traceDisplayEventIO :: (Display a, MonadIO m) => a -> m ()

traceDisplayEvent :: Display a => a -> b -> b

traceDisplayM :: (Display a, Applicative f) => a -> f ()

traceDisplayIO :: (Display a, MonadIO m) => a -> m ()

traceDisplayId :: Display a => a -> a

traceDisplay :: Display a => a -> b -> b

traceShowStack :: Show a => a -> b -> b

traceShowMarkerIO :: (Show a, MonadIO m) => a -> m ()

traceShowMarker :: Show a => a -> b -> b

traceShowEventIO :: (Show a, MonadIO m) => a -> m ()

traceShowEvent :: Show a => a -> b -> b

traceShowM :: (Show a, Applicative f) => a -> f ()

traceShowIO :: (Show a, MonadIO m) => a -> m ()

traceShowId :: Show a => a -> a

traceShow :: Show a => a -> b -> b

traceStack :: Text -> a -> a

traceMarkerIO :: MonadIO m => Text -> m ()

traceMarker :: Text -> a -> a

traceEventIO :: MonadIO m => Text -> m ()

traceEvent :: Text -> a -> a

traceM :: Applicative f => Text -> f ()

traceIO :: MonadIO m => Text -> m ()

traceId :: Text -> Text

trace :: Text -> a -> a

-- | Run with a default configured <tt>SimpleApp</tt>, consisting of:
--   
--   <ul>
--   <li>Logging to stderr</li>
--   <li>If the <tt>RIO_VERBOSE</tt> environment variable is set, turns on
--   verbose logging</li>
--   <li>Default process context</li>
--   </ul>
runSimpleApp :: MonadIO m => RIO SimpleApp a -> m a

-- | Constructor for <a>SimpleApp</a>. In case when <a>ProcessContext</a>
--   is not supplied <a>mkDefaultProcessContext</a> will be used to create
--   it.
mkSimpleApp :: MonadIO m => LogFunc -> Maybe ProcessContext -> m SimpleApp

-- | A simple, non-customizable environment type for <tt>RIO</tt>, which
--   provides common functionality. If it's insufficient for your needs,
--   define your own, custom <tt>App</tt> data type.
data SimpleApp

-- | create a new unboxed SomeRef
newUnboxedSomeRef :: (MonadIO m, Unbox a) => a -> m (SomeRef a)

-- | create a new boxed SomeRef
newSomeRef :: MonadIO m => a -> m (SomeRef a)

-- | Modify a SomeRef This function is subject to change due to the lack of
--   atomic operations
modifySomeRef :: MonadIO m => SomeRef a -> (a -> a) -> m ()

-- | Write to a SomeRef
writeSomeRef :: MonadIO m => SomeRef a -> a -> m ()

-- | Read from a SomeRef
readSomeRef :: MonadIO m => SomeRef a -> m a

-- | Lift one RIO env to another.
mapRIO :: (outer -> inner) -> RIO inner a -> RIO outer a

-- | Abstract <a>RIO</a> to an arbitrary <a>MonadReader</a> instance, which
--   can handle IO.
liftRIO :: (MonadIO m, MonadReader env m) => RIO env a -> m a

-- | Using the environment run in IO the action that requires that
--   environment.
runRIO :: MonadIO m => env -> RIO env a -> m a

-- | The Reader+IO monad. This is different from a <a>ReaderT</a> because:
--   
--   <ul>
--   <li>It's not a transformer, it hardcodes IO for simpler usage and
--   error messages.</li>
--   <li>Instances of typeclasses like <tt>MonadLogger</tt> are implemented
--   using classes defined on the environment, instead of using an
--   underlying monad.</li>
--   </ul>
newtype RIO env a
RIO :: ReaderT env IO a -> RIO env a
[unRIO] :: RIO env a -> ReaderT env IO a

-- | Abstraction over how to read from and write to a mutable reference
data SomeRef a

-- | Environment values with stateful capabilities to SomeRef
class HasStateRef s env | env -> s
stateRefL :: HasStateRef s env => Lens' env (SomeRef s)

-- | Environment values with writing capabilities to SomeRef
class HasWriteRef w env | env -> w
writeRefL :: HasWriteRef w env => Lens' env (SomeRef w)

-- | Modify a value in a <a>URef</a>. Note that this action is strict, and
--   will force evaluation of the result value.
modifyURef :: (PrimMonad m, Unbox a) => URef (PrimState m) a -> (a -> a) -> m ()

-- | Write a value into a <a>URef</a>. Note that this action is strict, and
--   will force evalution of the value.
writeURef :: (PrimMonad m, Unbox a) => URef (PrimState m) a -> a -> m ()

-- | Read the value in a <a>URef</a>
readURef :: (PrimMonad m, Unbox a) => URef (PrimState m) a -> m a

-- | Create a new <a>URef</a>
newURef :: (PrimMonad m, Unbox a) => a -> m (URef (PrimState m) a)

-- | An unboxed reference. This works like an <a>IORef</a>, but the data is
--   stored in a bytearray instead of a heap object, avoiding significant
--   allocation overhead in some cases. For a concrete example, see this
--   Stack Overflow question:
--   <a>https://stackoverflow.com/questions/27261813/why-is-my-little-stref-int-require-allocating-gigabytes</a>.
--   
--   The first parameter is the state token type, the same as would be used
--   for the <a>ST</a> monad. If you're using an <a>IO</a>-based monad, you
--   can use the convenience <a>IOURef</a> type synonym instead.
data URef s a

-- | Helpful type synonym for using a <a>URef</a> from an <a>IO</a>-based
--   stack.
type IOURef = URef PrimState IO

-- | Yield an immutable copy of the underlying mutable vector. The
--   difference from <a>dequeToVector</a> is that the the copy will be
--   performed with a more efficient <tt>memcpy</tt>, rather than element
--   by element. The downside is that the resulting vector type must be the
--   one that corresponds to the mutable one that is used in the
--   <a>Deque</a>.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import qualified RIO.Vector.Unboxed as U
--   
--   &gt;&gt;&gt; d &lt;- newDeque @U.MVector @Int
--   
--   &gt;&gt;&gt; mapM_ (pushFrontDeque d) [0..10]
--   
--   &gt;&gt;&gt; freezeDeque @U.Vector d
--   [10,9,8,7,6,5,4,3,2,1,0]
--   </pre>
freezeDeque :: (Vector v a, PrimMonad m) => Deque (Mutable v) (PrimState m) a -> m (v a)

-- | Convert to an immutable vector of any type. If resulting pure vector
--   corresponds to the mutable one used by the <a>Deque</a>, it will be
--   more efficient to use <a>freezeDeque</a> instead.
--   
--   <h4><b>Example</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import qualified RIO.Vector.Unboxed as U
--   
--   &gt;&gt;&gt; import qualified RIO.Vector.Storable as S
--   
--   &gt;&gt;&gt; d &lt;- newDeque @U.MVector @Int
--   
--   &gt;&gt;&gt; mapM_ (pushFrontDeque d) [0..10]
--   
--   &gt;&gt;&gt; dequeToVector @S.Vector d
--   [10,9,8,7,6,5,4,3,2,1,0]
--   </pre>
dequeToVector :: forall v' a (v :: Type -> Type -> Type) m. (Vector v' a, MVector v a, PrimMonad m) => Deque v (PrimState m) a -> m (v' a)

-- | Convert a <a>Deque</a> into a list. Does not modify the <a>Deque</a>.
dequeToList :: forall (v :: Type -> Type -> Type) a m. (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> m [a]

-- | Fold over a <a>Deque</a>, starting at the end. Does not modify the
--   <a>Deque</a>.
foldrDeque :: forall (v :: Type -> Type -> Type) a m acc. (MVector v a, PrimMonad m) => (a -> acc -> m acc) -> acc -> Deque v (PrimState m) a -> m acc

-- | Fold over a <a>Deque</a>, starting at the beginning. Does not modify
--   the <a>Deque</a>.
foldlDeque :: forall (v :: Type -> Type -> Type) a m acc. (MVector v a, PrimMonad m) => (acc -> a -> m acc) -> acc -> Deque v (PrimState m) a -> m acc

-- | Push a new value to the end of the <a>Deque</a>
pushBackDeque :: forall (v :: Type -> Type -> Type) a m. (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> a -> m ()

-- | Push a new value to the beginning of the <a>Deque</a>
pushFrontDeque :: forall (v :: Type -> Type -> Type) a m. (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> a -> m ()

-- | Pop the first value from the end of the <a>Deque</a>
popBackDeque :: forall (v :: Type -> Type -> Type) a m. (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> m (Maybe a)

-- | Pop the first value from the beginning of the <a>Deque</a>
popFrontDeque :: forall (v :: Type -> Type -> Type) a m. (MVector v a, PrimMonad m) => Deque v (PrimState m) a -> m (Maybe a)

-- | <i>O(1)</i> - Get the number of elements that is currently in the
--   <a>Deque</a>
getDequeSize :: forall m (v :: Type -> Type -> Type) a. PrimMonad m => Deque v (PrimState m) a -> m Int

-- | Create a new, empty <a>Deque</a>
newDeque :: forall (v :: Type -> Type -> Type) a m. (MVector v a, PrimMonad m) => m (Deque v (PrimState m) a)

-- | Helper function to assist with type inference, forcing usage of a
--   boxed vector.
asBDeque :: BDeque s a -> BDeque s a

-- | Helper function to assist with type inference, forcing usage of a
--   storable vector.
asSDeque :: SDeque s a -> SDeque s a

-- | Helper function to assist with type inference, forcing usage of an
--   unboxed vector.
asUDeque :: UDeque s a -> UDeque s a

-- | A double-ended queue supporting any underlying vector type and any
--   monad.
--   
--   This implements a circular double-ended queue with exponential growth.
data Deque (v :: Type -> Type -> Type) s a

-- | A <a>Deque</a> specialized to unboxed vectors.
type UDeque = Deque MVector

-- | A <a>Deque</a> specialized to storable vectors.
type SDeque = Deque MVector

-- | A <a>Deque</a> specialized to boxed vectors.
type BDeque = Deque MVector

-- | Read a file in UTF8 encoding, throwing an exception on invalid
--   character encoding.
--   
--   This function will use OS-specific line ending handling.
readFileUtf8 :: MonadIO m => FilePath -> m Text

-- | Same as <a>writeFile</a>, but generalized to <a>MonadIO</a>
writeFileBinary :: MonadIO m => FilePath -> ByteString -> m ()

-- | Same as <a>readFile</a>, but generalized to <a>MonadIO</a>
readFileBinary :: MonadIO m => FilePath -> m ByteString
hPutBuilder :: MonadIO m => Handle -> Builder -> m ()

-- | Write a file in UTF8 encoding
--   
--   This function will use OS-specific line ending handling.
writeFileUtf8 :: MonadIO m => FilePath -> Text -> m ()

-- | Lazily read a file in UTF8 encoding.
withLazyFileUtf8 :: MonadUnliftIO m => FilePath -> (Text -> m a) -> m a

-- | Lazily get the contents of a file. Unlike <a>readFile</a>, this
--   ensures that if an exception is thrown, the file handle is closed
--   immediately.
withLazyFile :: MonadUnliftIO m => FilePath -> (ByteString -> m a) -> m a

-- | Make a <a>GLogFunc</a> via classic <a>LogFunc</a>. Use this if you'd
--   like to log your generic data type via the classic RIO terminal
--   logger.
gLogFuncClassic :: (HasLogLevel msg, HasLogSource msg, Display msg) => LogFunc -> GLogFunc msg

-- | Log a value generically.
glog :: (MonadIO m, HasCallStack, HasGLogFunc env, MonadReader env m) => GMsg env -> m ()

-- | Make a custom generic logger. With this you could, for example, write
--   to a database or a log digestion service. For example:
--   
--   <pre>
--   mkGLogFunc (\stack msg -&gt; send (Data.Aeson.encode (JsonLog stack msg)))
--   </pre>
mkGLogFunc :: (CallStack -> msg -> IO ()) -> GLogFunc msg

-- | A contramap. Use this to wrap sub-loggers via <a>mapRIO</a>.
--   
--   If you are on base &gt; 4.12.0, you can just use <a>contramap</a>.
contramapGLogFunc :: (a -> b) -> GLogFunc b -> GLogFunc a

-- | A vesion of <a>contramapMaybeGLogFunc</a> which supports filering.
contramapMaybeGLogFunc :: (a -> Maybe b) -> GLogFunc b -> GLogFunc a

-- | Disable logging capabilities in a given sub-routine
--   
--   Intended to skip logging in general purpose implementations, where
--   secrets might be logged accidently.
noLogging :: (HasLogFunc env, MonadReader env m) => m a -> m a

-- | Is the log func configured to use color output?
--   
--   Intended for use by code which wants to optionally add additional
--   color to its log messages.
logFuncUseColorL :: HasLogFunc env => SimpleGetter env Bool

-- | Convert a <a>CallStack</a> value into a <a>Utf8Builder</a> indicating
--   the first source location.
--   
--   TODO Consider showing the entire call stack instead.
displayCallStack :: CallStack -> Utf8Builder

-- | Set format method for messages
--   
--   Default: <a>id</a>
setLogFormat :: (Utf8Builder -> Utf8Builder) -> LogOptions -> LogOptions

-- | Use code location in the log output.
--   
--   Default: <a>True</a> if in verbose mode, <a>False</a> otherwise.
setLogUseLoc :: Bool -> LogOptions -> LogOptions

-- | Use ANSI color codes in the log output.
--   
--   Default: <a>True</a> if in verbose mode <i>and</i> the <a>Handle</a>
--   is a terminal device.
setLogUseColor :: Bool -> LogOptions -> LogOptions

-- | Include the time when printing log messages.
--   
--   Default: <a>True</a> in debug mode, <a>False</a> otherwise.
setLogUseTime :: Bool -> LogOptions -> LogOptions

-- | Do we treat output as a terminal. If <tt>True</tt>, we will enabled
--   sticky logging functionality.
--   
--   Default: checks if the <tt>Handle</tt> provided to
--   <a>logOptionsHandle</a> is a terminal with <a>hIsTerminalDevice</a>.
setLogTerminal :: Bool -> LogOptions -> LogOptions

-- | Refer to <a>setLogVerboseFormat</a>. This modifier allows to alter the
--   verbose format value dynamically at runtime.
--   
--   Default: follows the value of the verbose flag.
setLogVerboseFormatIO :: IO Bool -> LogOptions -> LogOptions

-- | Use the verbose format for printing log messages.
--   
--   Default: follows the value of the verbose flag.
setLogVerboseFormat :: Bool -> LogOptions -> LogOptions

-- | Refer to <a>setLogMinLevel</a>. This modifier allows to alter the
--   verbose format value dynamically at runtime.
--   
--   Default: in verbose mode, <a>LevelDebug</a>. Otherwise,
--   <a>LevelInfo</a>.
setLogMinLevelIO :: IO LogLevel -> LogOptions -> LogOptions

-- | Set the minimum log level. Messages below this level will not be
--   printed.
--   
--   Default: in verbose mode, <a>LevelDebug</a>. Otherwise,
--   <a>LevelInfo</a>.
setLogMinLevel :: LogLevel -> LogOptions -> LogOptions

-- | Given a <a>LogOptions</a> value, run the given function with the
--   specified <a>LogFunc</a>. A common way to use this function is:
--   
--   <pre>
--   let isVerbose = False -- get from the command line instead
--   logOptions' &lt;- logOptionsHandle stderr isVerbose
--   let logOptions = setLogUseTime True logOptions'
--   withLogFunc logOptions $ \lf -&gt; do
--     let app = App -- application specific environment
--           { appLogFunc = lf
--           , appOtherStuff = ...
--           }
--     runRIO app $ do
--       logInfo "Starting app"
--       myApp
--   </pre>
withLogFunc :: MonadUnliftIO m => LogOptions -> (LogFunc -> m a) -> m a

-- | Given a <a>LogOptions</a> value, returns both a new <a>LogFunc</a> and
--   a sub-routine that disposes it.
--   
--   Intended for use if you want to deal with the teardown of
--   <a>LogFunc</a> yourself, otherwise prefer the <a>withLogFunc</a>
--   function instead.
newLogFunc :: (MonadIO n, MonadIO m) => LogOptions -> n (LogFunc, m ())

-- | Create a <a>LogOptions</a> value from the given <a>Handle</a> and
--   whether to perform verbose logging or not. Individiual settings can be
--   overridden using appropriate <tt>set</tt> functions.
--   
--   When Verbose Flag is <tt>True</tt>, the following happens:
--   
--   <ul>
--   <li><tt>setLogVerboseFormat</tt> is called with <tt>True</tt></li>
--   <li><tt>setLogUseColor</tt> is called with <tt>True</tt> (except on
--   Windows)</li>
--   <li><tt>setLogUseLoc</tt> is called with <tt>True</tt></li>
--   <li><tt>setLogUseTime</tt> is called with <tt>True</tt></li>
--   <li><tt>setLogMinLevel</tt> is called with <tt>Debug</tt> log
--   level</li>
--   </ul>
logOptionsHandle :: MonadIO m => Handle -> Bool -> m LogOptions

-- | Create a <a>LogOptions</a> value which will store its data in memory.
--   This is primarily intended for testing purposes. This will return both
--   a <a>LogOptions</a> value and an <a>IORef</a> containing the resulting
--   <a>Builder</a> value.
--   
--   This will default to non-verbose settings and assume there is a
--   terminal attached. These assumptions can be overridden using the
--   appropriate <tt>set</tt> functions.
logOptionsMemory :: MonadIO m => m (IORef Builder, LogOptions)

-- | This will print out the given message with a newline and disable any
--   further stickiness of the line until a new call to <a>logSticky</a>
--   happens.
logStickyDone :: (MonadIO m, HasCallStack, MonadReader env m, HasLogFunc env) => Utf8Builder -> m ()

-- | Write a "sticky" line to the terminal. Any subsequent lines will
--   overwrite this one, and that same line will be repeated below again.
--   In other words, the line sticks at the bottom of the output forever.
--   Running this function again will replace the sticky line with a new
--   sticky line. When you want to get rid of the sticky line, run
--   <a>logStickyDone</a>.
--   
--   Note that not all <a>LogFunc</a> implementations will support sticky
--   messages as described. However, the <a>withLogFunc</a> implementation
--   provided by this module does.
logSticky :: (MonadIO m, HasCallStack, MonadReader env m, HasLogFunc env) => Utf8Builder -> m ()

-- | Log a message with the specified textual level and the given source.
logOtherS :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => Text -> LogSource -> Utf8Builder -> m ()

-- | Log an error level message with the given source.
logErrorS :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => LogSource -> Utf8Builder -> m ()

-- | Log a warn level message with the given source.
logWarnS :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => LogSource -> Utf8Builder -> m ()

-- | Log an info level message with the given source.
logInfoS :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => LogSource -> Utf8Builder -> m ()

-- | Log a debug level message with the given source.
logDebugS :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => LogSource -> Utf8Builder -> m ()

-- | Log a message with the specified textual level and no source.
logOther :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => Text -> Utf8Builder -> m ()

-- | Log an error level message with no source.
logError :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => Utf8Builder -> m ()

-- | Log a warn level message with no source.
logWarn :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => Utf8Builder -> m ()

-- | Log an info level message with no source.
logInfo :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => Utf8Builder -> m ()

-- | Log a debug level message with no source.
logDebug :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => Utf8Builder -> m ()

-- | Generic, basic function for creating other logging functions.
logGeneric :: (MonadIO m, MonadReader env m, HasLogFunc env, HasCallStack) => LogSource -> LogLevel -> Utf8Builder -> m ()

-- | Create a <a>LogFunc</a> from the given function.
mkLogFunc :: (CallStack -> LogSource -> LogLevel -> Utf8Builder -> IO ()) -> LogFunc

-- | The log level of a message.
data LogLevel
LevelDebug :: LogLevel
LevelInfo :: LogLevel
LevelWarn :: LogLevel
LevelError :: LogLevel
LevelOther :: !Text -> LogLevel

-- | Where in the application a log message came from. Used for display
--   purposes only.
type LogSource = Text

-- | Environment values with a logging function.
class HasLogFunc env
logFuncL :: HasLogFunc env => Lens' env LogFunc

-- | A logging function, wrapped in a newtype for better error messages.
--   
--   An implementation may choose any behavior of this value it wishes,
--   including printing to standard output or no action at all.
data LogFunc

-- | Configuration for how to create a <a>LogFunc</a>. Intended to be used
--   with the <a>withLogFunc</a> function.
data LogOptions
type family GMsg env

-- | An app is capable of generic logging if it implements this.
class HasGLogFunc env where {
    type family GMsg env;
}
gLogFuncL :: HasGLogFunc env => Lens' env (GLogFunc (GMsg env))

-- | A generic logger of some type <tt>msg</tt>.
--   
--   Your <tt>GLocFunc</tt> can re-use the existing classical logging
--   framework of RIO, and/or implement additional transforms, filters.
--   Alternatively, you may log to a JSON source in a database, or anywhere
--   else as needed. You can decide how to log levels or severities based
--   on the constructors in your type. You will normally determine this in
--   your main app entry point.
data GLogFunc msg

-- | Level, if any, of your logs. If unknown, use <tt>LogOther</tt>. Use
--   for your generic log data types that want to sit inside the classic
--   log framework.
class HasLogLevel msg
getLogLevel :: HasLogLevel msg => msg -> LogLevel

-- | Source of a log. This can be whatever you want. Use for your generic
--   log data types that want to sit inside the classic log framework.
class HasLogSource msg
getLogSource :: HasLogSource msg => msg -> LogSource
decodeUtf8Lenient :: ByteString -> Text
tshow :: Show a => a -> Text
yieldThread :: MonadIO m => m ()
fromStrictBytes :: ByteString -> LByteString
toStrictBytes :: LByteString -> ByteString
sappend :: Semigroup s => s -> s -> s
type UVector = Vector
type SVector = Vector
type GVector = Vector
type LByteString = ByteString
type LText = Text
view :: MonadReader s m => Getting a s a -> m a

-- | Helper function to force an action to run in <a>IO</a>. Especially
--   useful for overly general contexts, like hspec tests.
asIO :: IO a -> IO a

-- | Run the second value if the first value returns <a>False</a>
unlessM :: Monad m => m Bool -> m () -> m ()

-- | Run the second value if the first value returns <a>True</a>
whenM :: Monad m => m Bool -> m () -> m ()

-- | Strip out duplicates
nubOrd :: Ord a => [a] -> [a]

-- | Extend <a>foldMap</a> to allow side effects.
--   
--   Internally, this is implemented using a strict left fold. This is used
--   for performance reasons. It also necessitates that this function has a
--   <tt>Monad</tt> constraint and not just an <tt>Applicative</tt>
--   constraint. For more information, see
--   <a>https://github.com/commercialhaskell/rio/pull/99#issuecomment-394179757</a>.
foldMapM :: (Monad m, Monoid w, Foldable t) => (a -> m w) -> t a -> m w

-- | <pre>
--   <a>forMaybeM</a> <a>==</a> <a>flip</a> <a>mapMaybeM</a>
--   </pre>
forMaybeM :: Monad m => [a] -> (a -> m (Maybe b)) -> m [b]

-- | Monadic <a>mapMaybe</a>.
mapMaybeM :: Monad m => (a -> m (Maybe b)) -> [a] -> m [b]

-- | <pre>
--   <a>forMaybeA</a> <a>==</a> <a>flip</a> <a>mapMaybeA</a>
--   </pre>
forMaybeA :: Applicative f => [a] -> (a -> f (Maybe b)) -> f [b]

-- | Applicative <a>mapMaybe</a>.
mapMaybeA :: Applicative f => (a -> f (Maybe b)) -> [a] -> f [b]

-- | Get a <a>First</a> value with a default fallback
fromFirst :: a -> First a -> a

-- | Apply a function to a <a>Left</a> constructor
mapLeft :: (a1 -> a2) -> Either a1 b -> Either a2 b

-- | Lifted version of "System.Exit.exitWith".
--   
--   @since 0.1.9.0.
exitWith :: MonadIO m => ExitCode -> m a

-- | Lifted version of "System.Exit.exitSuccess".
--   
--   @since 0.1.9.0.
exitSuccess :: MonadIO m => m a

-- | Lifted version of "System.Exit.exitFailure".
--   
--   @since 0.1.9.0.
exitFailure :: MonadIO m => m a

-- | Write the given <a>Utf8Builder</a> value to a file.
writeFileUtf8Builder :: MonadIO m => FilePath -> Utf8Builder -> m ()

-- | Convert a <a>Utf8Builder</a> value into a lazy <a>Text</a>.
utf8BuilderToLazyText :: Utf8Builder -> Text

-- | Convert a <a>Utf8Builder</a> value into a strict <a>Text</a>.
utf8BuilderToText :: Utf8Builder -> Text

-- | Convert a <a>ByteString</a> into a <a>Utf8Builder</a>.
--   
--   <i>NOTE</i> This function performs no checks to ensure that the data
--   is, in fact, UTF8 encoded. If you provide non-UTF8 data, later
--   functions may fail.
displayBytesUtf8 :: ByteString -> Utf8Builder

-- | Use the <a>Show</a> instance for a value to convert it to a
--   <a>Utf8Builder</a>.
displayShow :: Show a => a -> Utf8Builder

-- | A builder of binary data, with the invariant that the underlying data
--   is supposed to be UTF-8 encoded.
newtype Utf8Builder
Utf8Builder :: Builder -> Utf8Builder
[getUtf8Builder] :: Utf8Builder -> Builder

-- | A typeclass for values which can be converted to a <a>Utf8Builder</a>.
--   The intention of this typeclass is to provide a human-friendly display
--   of the data.
class Display a
display :: Display a => a -> Utf8Builder

-- | Display data as <a>Text</a>, which will also be used for
--   <a>display</a> if it is not overriden.
textDisplay :: Display a => a -> Text

-- | Unlifted version of <a>withBinaryFile</a>.
withBinaryFile :: MonadUnliftIO m => FilePath -> IOMode -> (Handle -> m a) -> m a

-- | Lifted version of <a>myThreadId</a>.
myThreadId :: MonadIO m => m ThreadId

-- | Lifted version of <a>threadDelay</a>.
threadDelay :: MonadIO m => Int -> m ()

-- | Lifted version of <a>threadWaitRead</a>.
threadWaitRead :: MonadIO m => Fd -> m ()

-- | Lifted version of <a>threadWaitWrite</a>.
threadWaitWrite :: MonadIO m => Fd -> m ()

-- | Lifted version of <a>isCurrentThreadBound</a>.
isCurrentThreadBound :: MonadIO m => m Bool

-- | An exception type for representing Unicode encoding errors.
data UnicodeException

-- | Could not decode a byte sequence because it was invalid under the
--   given encoding, or ran out of input in mid-decode.
DecodeError :: String -> Maybe Word8 -> UnicodeException

-- | Tried to encode a character that could not be represented under the
--   given encoding, or ran out of input in mid-encode.
EncodeError :: String -> Maybe Char -> UnicodeException

-- | Replace an invalid input byte with the Unicode replacement character
--   U+FFFD.
lenientDecode :: OnDecodeError

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text.
--   
--   <b>NOTE</b>: The replacement character returned by
--   <a>OnDecodeError</a> MUST be within the BMP plane; surrogate code
--   points will automatically be remapped to the replacement char
--   <tt>U+FFFD</tt> (<i>since 0.11.3.0</i>), whereas code points beyond
--   the BMP will throw an <a>error</a> (<i>since 1.2.3.1</i>); For earlier
--   versions of <tt>text</tt> using those unsupported code points would
--   result in undefined behavior.
decodeUtf8With :: OnDecodeError -> ByteString -> Text

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text.
--   
--   If the input contains any invalid UTF-8 data, the relevant exception
--   will be returned, otherwise the decoded text.
decodeUtf8' :: ByteString -> Either UnicodeException Text

-- | Encode text to a ByteString <a>Builder</a> using UTF-8 encoding.
encodeUtf8Builder :: Text -> Builder

-- | Encode text using UTF-8 encoding.
encodeUtf8 :: Text -> ByteString

module System.SED.Host.Run
run :: RIO App ()

module System.SED.TPer.Run
run :: RIO App ()
